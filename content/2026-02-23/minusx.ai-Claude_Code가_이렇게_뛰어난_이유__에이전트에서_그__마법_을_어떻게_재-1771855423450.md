# reddit 유저의 클로드 코드 6개월 사용 후기

- 원문 링크: https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/
- 저자: JokeGold5455
- 출처: www.reddit.com

# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까

원문 링크: https://minusx.ai/blog/decoding-claude-code/?utm_source=tldrnewsletter

원문 서명/출처: vivek (@nuwandavek), MinusX

## 이미지 설명
- Claude Code 업데이트 차이를 선명하게 확인할 수 있음

# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까

/ [vivek](https://x.com/nuwandavek) / 2025-08-21

Claude Code는 지금까지 내가 써 본 AI 에이전트/워크플로우 중 가장 쓰기 편한 도구다. 타깃 편집이나 즉흥적인 vibe 코딩에 쓰는 도구보다 단순히 덜짜증나는 수준을 넘어, 실제로 쓰는 사람이 만족감을 느끼게 만든다. 강력한 자율성으로 꽤 많은 일을 시킬 수 있으면서도, 다른 일부 도구들처럼 “제어권을 잃는 듯한” 이질감은 덜 준다. 물론 핵심적인 작업량은 최신 Claude 4 모델(특히 interleaved thinking, `문맥을 반씩 번갈아가며 판단하는 방식`(원문: "interleaved thinking")이) 덕분이다.

동일 모델을 쓰는 Cursor나 GitHub Copilot 에이전트와 비교해도, Claude Code는 상대적으로 덜 번거롭게 느껴진다. 왜 이렇게까지 좋다고 느꼈을까? 이 글을 읽고 고개가 끄덕여진다면, 그 이유를 정리해보려 한다.

참고: 이것은 Claude Code의 내부 구조를 공개하는 글이 아니다. 그 같은 글은 이미 충분히 존재한다. 이 글은 몇 달간의 직접 사용과 실측 로그 분석을 바탕으로, ‘쓸 만한 LLM 에이전트’를 만들기 위한 실무 가이드이다. 부록에서 프롬프트와 도구를 볼 수 있다. 약 2천 단어 분량이므로, 짧게 보려면 TL;DR부터 보는 게 좋다.

이미지: prompts

Claude Code의 업그레이드 흐름이 분명히 보임

Claude Code(이하 CC)는 직관적으로 잘 동작한다. 이는 단순히 사용자 경험이 좋다는 뜻이 아니라, LLM이 잘하는 일과 못하는 일을 명확히 반영해 설계했기 때문이다. 프롬프트와 도구가 모델의 약점을 가리고 강점을 부각한다. 그래서 제어 루프가 매우 단순하고 디버깅하기 쉽다.

MinusX에서는 공개 직후 바로 CC를 도입했다. 내부에서 덮어쓰기 없이 네트워크 요청을 가로채고 기록하는 로거를 만들어 분석 기반으로 사용했고, 아래 내용은 마지막 몇 개월간 집중 사용한 결과다. 이 글의 핵심 질문은 바로 이것이다. “Claude Code가 왜 그렇게 좋은가? 내 채팅형 LLM 에이전트에서도 같은 경험을 만들 수는 없을까?” 현재 대부분을 MinusX에 반영했고, 독자도 그대로 적용해보길 권한다.

이미지: prompts

가장 빈번하게 쓰이는 도구 순서는 Edit → Read → ToDoWrite였다.

## Claude Code형 에이전트를 만드는 법: TL;DR

한마디로 정리하면 이렇다. **복잡하게 가지 말고 핵심만 유지해야 한다**(원문: “Keep Things Simple, Dummy”). (역자 주. “dummy”는 비격식적 강조어라 직역보다 ‘핵심 단순화’로 의역했다.)

LLM은 디버깅과 평가 자체가 어렵다. 여기에 멀티에이전트, 에이전트 인계 구조, 복잡한 RAG 검색 알고리즘 같은 추가 복잡성을 더하면 문제 해결이 10배 더 어려워진다. 겉보기엔 잘 돌아가는 취약한 시스템도, 한 번 돌아가기 시작하면 나중에 구조를 바꾸는 게 공포로 다가온다. 그래서 가능한 한 하나의 파일에 핵심을 두고, 과도한 보일러플레이트는 반복적으로 제거하는 게 낫다.

Claude Code에서 가져갈 핵심 정리:

### 1. 제어 루프
- 1.1 한 개의 메인 루프(최대 한 갈래 분기)와 하나의 메시지 이력 유지
- 1.2 거의 모든 단계에서 소형 모델 사용

### 2. 프롬프트
- 2.1 claude.md 패턴으로 사용자 선호를 공유·기억
- 2.2 특수 XML 태그, Markdown, 그리고 풍부한 예시

### 3. 도구
- 3.1 LLM 기반 검색이 RAG 기반 검색보다 우선
- 3.2 좋은 도구 설계(고수준 vs 저수준)
- 3.3 에이전트가 자기 todo 목록을 직접 관리

### 4. 조정 가능성(steerability)
- 4.1 말투와 스타일
- 4.2 “PLEASE THIS IS IMPORTANT”류의 강조 표현이 여전히 현실적인 조정 수단
- 4.3 규칙을 나열하기보다 알고리즘·휴리스틱·예시로 설명

> Claude Code는 아키텍처 수준에서 단순함을 택한다. 하나의 메인 루프, 간단한 검색, 단순한 todo 목록 등을 유지한다. 과도한 설계 대신 잘 제어된 실험 환경을 만들어 모델이 스스로 ‘요리’하게 두는 방식이다.
> (원문: “Is this end-to-end self-driving all over again? Bitter lesson much?”)

---

## 1. 제어 루프 설계

### 1.1 하나의 메인 루프만 유지

디버깅 가능성은 다단계 다중 에이전트 구성을 넘는다.

멀티 에이전트가 유행인 시대에도 CC는 실제로 하나의 메인 스레드만 유지한다. 필요한 경우에만, git 히스토리를 요약하거나 메시지 이력을 하나로 압축하거나 UX 장식을 구성하는 특수 프롬프트를 주기적으로 사용한다. 다만 전반적으로는 평평한(flat) 메시지 목록을 유지한다.

계층형 작업 처리 또한 독특하게 접근한다. 추가 하위 에이전트를 생성하되, 새 하위 에이전트가 또다시 하위 에이전트를 만들 수는 없다.

최대 한 갈래의 분기만 허용되고, 그 결과는 `tool response` 형태로 메인 메시지 이력에 반영된다.

문제가 단순하면 메인 루프는 반복적인 도구 호출로 처리한다. 하지만 작업이 하나 이상의 복합 문제일 경우, 메인 에이전트가 자기 자신을 복제해 분기한다. 최대 한 갈래 제한과 todo 목록을 같이 쓰면, 문제를 하위 작업으로 나누되 최종 목표를 계속 바라볼 수 있다.

내가 보기엔 다중 에이전트 구조가 꼭 필요할 가능성은 낮다. 추상화 계층이 늘어날수록 디버깅 난이도는 올라가고, 무엇보다 모델의 일반적 성능 개선 흐름에서 멀어질 수 있다.

이미지: Control Loop

### 1.2 모든 일에 작은 모델 사용

CC의 주요 LLM 호출의 50% 이상이 claude-3-5-haiku로 처리되었다. 이 모델은 대용량 파일 읽기, 웹 페이지 파싱, git 히스토리 처리, 긴 대화 요약 같은 일에 쓰이며, 매 입력마다 1단어 처리 라벨을 생성하는 데까지 활용된다(`one-word processing label`, 원문: "for every key stroke").

소형 모델은 Sonnet 4, GPT-4.1 같은 표준 모델 대비 70~80% 저렴하다. 과감히 써야 한다.

## 2. 프롬프트

Claude Code는 상당히 정교한 프롬프트를 사용한다. 휴리스틱, 예시, 그리고 IMPORTANT(원문: "IMPORTANT") 형태의 리마인더가 빈번하다. 시스템 프롬프트는 약 2800 토큰이며, 도구 설명은 약 9400 토큰 수준이다. 사용자 프롬프트에는 대개 claude.md가 들어가고, 보통 1000~2000 토큰이 추가된다.

시스템 프롬프트에는 말투, 스타일, 선제성, 작업 관리, 도구 사용 정책, 작업 수행 방식이 모두 들어가고, 현재 날짜·작업 디렉터리·플랫폼·OS 정보·최근 커밋 내역 같은 실행 메타데이터도 반영된다.

프롬프트 전부를 한 번 읽어보는 걸 권한다.

### 2.1 claude.md로 사용자 맥락·선호도 협업

많은 코딩 에이전트 제작자가 채택한 패턴은 컨텍스트 파일이다(CURSOR Rules / claude.md / agent.md 계열). CC는 claude.md 유무에 따라 성능 차이가 극단적으로 크다. 코드베이스에서 추론할 수 없는 팀/사용자 맥락을 전달하고, 강한 선호 조건을 고정하는 데 유용하다. 예를 들어 특정 폴더를 건너뛰거나 특정 라이브러리 사용을 강제할 수 있다. CC는 매 사용자 요청마다 claude.md 전체를 함께 전달한다.

MinusX는 최근 `minusx.md`를 도입했다(원문: minusx.md). 내부적으로 팀·사용자 선호를 한 파일로 정리해 에이전트가 일관되게 따르도록 했다.

### 2.2 특수 XML 태그, Markdown, 풍부한 예시

프롬프트 구조화에 XML 태그와 Markdown이 널리 쓰인다는 점은 이미 알려져 있다. CC는 이 두 방식 모두를 크게 사용한다.

CC에서 쓰는 주요 XML 예시:

- `<system-reminder>`: 여러 섹션 끝에 배치해 모델이 자주 깜박이는 내용을 되새기게 함.

  예시:

  `<system-reminder>현재 todo 목록이 비어 있음을 상기합니다. 사용자에게는 이 사실을 굳이 알릴 필요 없습니다. todo 목록이 유리한 작업에서는 TodoWrite를 사용하세요. 필요 없다면 무시해도 됩니다. 이 메시지도 사용자에게 직접 노출하지 마세요.</system-reminder>`

- `<good-example>`, `<bad-example>`: 휴리스틱을 고정하는 용도로 사용.

  여러 합리적 경로가 동시에 열려 있을 때, 어떤 선택이 더 맞는지 대비가 필요할 때 유용하다.

  예시:

  `pytest /foo/bar/tests`가 좋은 예시이고

  `cd /foo/bar && pytest tests`는 나쁜 예시인 것을 대비해 보여준다.

또한 CC는 마크다운을 이용해 시스템 프롬프트를 명확한 절(section) 단위로 나눈다. 주요 섹션에는 말투·스타일, 선제성, 규약 준수, 코드 스타일, 작업 관리, 도구 사용 정책, 작업 실행, 도구 목록이 들어간다.

## 3. 도구

전체 도구 프롬프트 자체도 꼭 읽어볼 가치가 있다. (약 9400 토큰)

### 3.1 LLM 검색이 RAG 검색보다 유리

CC가 다른 인기 있는 코딩 에이전트와 구분되는 중요한 지점은 바로 RAG를 안 쓴다는 점이다. CC는 사용자가 직접 코드베이스를 다루는 것처럼 `ripgrep`, `jq`, `find` 같은 실제 검색 명령을 쓴다.

LLM이 코드를 잘 이해하므로, 관련 코드 블록을 정규표현식으로 꽤 정교하게 찾아낼 수 있다. 때로는 더 작은 모델로 전체 파일을 읽기도 한다.

RAG는 이론적으로 좋아 보이지만, 새로운 실패 모드가 생긴다. 유사도 함수가 무엇이어야 하는지, 리랭커는 무엇을 써야 하는지, 청크 단위는 어떻게 할지, 큰 JSON/로그를 어떻게 처리할지 등 판단 포인트가 많다.

LLM 검색은 반면 간단히 JSON에서 10줄을 읽어 구조를 파악하고, 필요하면 10줄씩 더 보는 식으로 동작한다. 무엇보다 학습 가능한(RL learnable) 구조라는 점이 장점이다. (원문: “RL learnable”).

무거운 모델 두 개를 엮는 구조보다 훨씬 단순하다. 또한 복잡한 고도형 구조를 이중으로 얽히게 두는 건 유지보수 측면에서도 거추장스럽다. (원문: “Camera vs Lidar” 비유는 두 기술 접근의 대비를 농담으로 강조한 것)

작가가 농담처럼 언급했듯, LLM 시대의 `Camera vs Lidar` 구도가 떠오른다(원문: “Camera vs Lidar of the LLM era”). 즉 완전히 극단적 이분법은 아니고, 반은 농담, 반은 진심에 가깝다. (역자 주. Lidar는 거리측정 센서, Camera는 저비용·저정밀 방식의 은유로 이해하면 된다.)

### 3.2 좋은 도구 설계: 저수준 vs 고수준

‘에이전트에 어떤 도구를 줘야 하나’는 만드는 사람이라면 밤잠을 설칠 수 있는 고민이다. 높은 수준의 의미 기반 작업을 주는가, 아니면 키보드 타이핑·클릭처럼 저수준을 주는가.

정답은 상황에 따라 다르고, 둘 다 써야 한다.

CC는 저수준(Bash, Read, Write), 중간(Edit, Grep, Glob), 고수준(Task, WebFetch, exit_plan_mode) 도구를 모두 둔다.

CC에 bash가 있으니 별도 Grep을 둘 필요가 없다는 의문이 들 수 있지만, 실제 사용 빈도를 보면 grep을 자주 쓰는 경향 때문에 따로 두는 편이 이득이다. 특수 상황에는 여전히 일반 bash 명령으로 처리한다.

WebFetch, `mcp__ide__getDiagnostics`처럼 동작이 매우 결정적인 고수준 도구 역시 있다. 이는 모델이 저수준 입력/클릭 과정을 반복하는 비용을 줄여, 문제 해결 흐름을 덜 비틀리게 한다. 즉, 모델 부담을 줄여 주는 설계다.

도구 설명은 구체적 예시를 많이 싣고, 같은 작업을 두 도구가 할 수 있을 때의 선택 기준까지 적어둔다.

CC의 도구 목록:

- Task
- Bash
- Glob
- Grep
- LS
- ExitPlanMode
- Read
- Edit
- MultiEdit
- Write
- NotebookEdit
- WebFetch
- TodoWrite
- WebSearch
- mcp__ide__getDiagnostics
- mcp__ide__executeCode

### 3.3 에이전트가 todo 목록 관리

긴 실행 시간의 LLM 에이전트에서 맥락 붕괴(context rot)는 흔하다. 초반엔 어려운 문제를 잘 시작하다도, 시간이 지나면 정체가 무너져 쓰레기처럼 돌아가기도 한다.

현재 에이전트들은 보통 명시적 todo를 실험한다: 한 모델이 todo를 만들고 다른 모델이 수행, 또는 PRD/PM → 구현 → QA의 다중 에이전트 승계 구조 같은 형태다.

그러나 다중 에이전트 인계 자체가 좋은 선택은 거의 아니라고 저자는 본다. CC는 명시적인 todo 목록을 쓰되, 그 목록을 모델이 직접 유지한다. 모델은 todo를 자주 참조하라고 강하게 유도되고, 구현 중간에도 필요하면 새 항목을 추가하거나 기존 항목을 거절·수정하며 유연하게 경로를 바꾼다. 이는 `interleaved thinking`을 이용해 흐름을 즉시 조정하는 방식이다. (원문: "interleaved thinking")

## 4. 조정 가능성(steerability)

### 4.1 말투와 스타일

CC는 에이전트의 ‘느낌 있는 동작’을 매우 의도적으로 통제한다. 시스템 프롬프트에는 말투, 스타일, 선제성 관련 섹션이 가득하며, 그것이 댓글 톤과 대응 태도까지 단정하게 만든다. 덕분에 코드 설명 없이도 정돈된 반응이 나온다.

저자는 이 부분을 그대로 가져다 앱에 적용할 것을 권한다.

예시:

- IMPORTANT: 사용자 요청이 없으면 불필요한 머리말/꼬리말(예: 코드 설명 요약, 액션 요약)을 붙이지 말 것.
- 요청하지 않은 기능 설명이나 정리도 기본적으로 생략.
- 도와주지 못할 때는 이유를 늘어놓지 말 것(설교처럼 보이고 짜증 유발).
- 이모지는 사용자가 분명히 요구하지 않으면 쓰지 말 것.

### 4.2 “이건 중요합니다”류 표현이 아직은 최선의 조정 수단

안타깝게도 모델이 “하지 말아야 할 일”을 따르게 만드는 건 여전히 어려운 편이다.

IMPORTANT, VERY IMPORTANT, NEVER, ALWAYS 같은 키워드가 지금으로선 지뢰 구간을 피하게 만드는 데 가장 안정적이다. 미래엔 더 자연스럽게 조정 가능한 단계가 오겠지만, 지금은 이런 방식이 실용적이다.

예시:

- IMPORTANT: 사용자가 요청하지 않은 한 코멘트를 추가하지 말 것
- VERY IMPORTANT: `find`, `grep`은 쓰지 말고 Grep, Glob, Task를 사용할 것
- `cat`, `head`, `tail`, `ls`도 가능하면 배제하고 Read/LS를 사용할 것
- 정말로 `grep`이 필요하면, `rg`부터 먼저 사용할 것
- IMPORTANT: URL은 코딩 도움에 확신이 있을 때만 생성·추측

### 4.3 알고리즘(휴리스틱+예시)로 작성

LLM이 수행할 핵심 작업을 먼저 식별해, 그에 대한 알고리즘을 명시하는 게 핵심이다. 실제 모델처럼 역할 연기를 하며 예시를 여러 번 돌려 판단 지점을 모두 드러내면, 지시를 지키기 쉬워진다.

큰 흐름도를 그리는 것도 유효한 방법이다. 이렇게 하면 의사결정이 구조화되고, 모델이 지시를 따라가기 쉬워진다.

“수많은 해야 할 일 / 하면 안 되는 일” 목록을 한꺼번에 쓰면 유지보수가 어렵고 충돌이 생기기 쉽다. 프롬프트가 수천 토큰이면 충돌 규칙이 생겨 모델이 취약해진다.

CC 시스템 프롬프트의 `Task Management`, `Doing Tasks`, `Tool Usage Policy` 항목은 이런 알고리즘을 구체적으로 제시하고, 수많은 상황별 휴리스틱·예시를 함께 제공한다.

## Bonus: BigLab 프롬프트를 주의 깊게 보는 이유

LLM 조정의 큰 비중은 사후 보정 데이터 분포(사실상 RLHF 경향)를 역추적하는 데 있다. JSON을 써야 하는지 XML을 써야 하는지, 도구 설명을 시스템 프롬프트에 넣을지 도구 정의로 둘지, 앱의 현재 상태는 어떻게 다룰지 같은 문제는 타사 구현을 보는 게 도움이 된다.

CC의 설계는 매우 강한 운영 철학(`opinionated` 경향)을 갖고 있고, 이를 참고해 내 시스템을 고치는 게 효과적이다.

## 결론

핵심은 여전히 단순함이다. 과도한 프레임워크와 외부 확장은 오히려 역효과가 날 수 있다. CC를 통해 “에이전트는 단순해도 충분히 강력할 수 있다”는 믿음을 얻었고, MinusX에서도 그 교훈을 계속 반영하고 있다.

자신만의 LLM 에이전트를 Claude식으로 정형화하고 싶다면, 저자는 대화나 공유를 환영한다고 밝혔다. 훈련 가능한 데이터 에이전트를 원한다면 MinusX를 참고하거나 데모를 신청하라.

Happy (Claude) Coding!

---

## 부록

- 메인 Claude Code 시스템 프롬프트 보기
- 전체 Claude Code 도구 보기

## 관련 글

- [블로그 글 목록 보기](https://minusx.ai/blog/)
- [Metabase AI](https://minusx.ai/metabase-ai/)
- [요금제 보기](https://minusx.ai/pricing/)

## 페이지 하단(번역)

최신 업데이트 알림 구독을 위해 이메일 주소를 입력해 구독할 수 있다.
이메일 주소
구독

연락: hi@minusx.ai

© 2025 MinusX, Inc. 모든 권리 보유.

### 제품

- Chrome 확장 프로그램
- Playground
- GitHub
- 문서

### 기능

- Metabase AI
- MBQL AI Assistant
- 대시보드 Q&A
- 임베디드 AI

### 회사

- 요금제
- 회사 소개
- 블로그
- 데모

### 지원

- 이용 약관
- 개인정보 보호 정책
- 신뢰 센터
- 지원

## 댓글 번역

- 본문 소스에 공개 댓글 섹션이 없어 번역할 댓글 본문은 없습니다.