# Harness engineering: 에이전트 우선 시대에서 Codex를 활용하는 방법

- 원문 링크: https://openai.com/index/harness-engineering/
- 저자: OpenAI, Ryan Lopopolo
- 출처: openai.com

# Harness engineering: 에이전트 우선 시대에서 Codex를 활용하는 방법

원문 링크: https://openai.com/index/harness-engineering/

원문 서명/출처: Ryan Lopopolo, Member of the Technical Staff (OpenAI)

원문 발행일: 2026-02-11

업로드 시각: 2026-02-23 23:00:58 KST (문서 생성 기준)

최종 수정 시각: 2026-02-23 23:00:58 KST (문서 생성 기준)

## 목차

- 빈 깃 저장소에서 시작하기
- 엔지니어 역할의 재정의
- 애플리케이션 가시성(legibility) 높이기
- 저장소 지식을 시스템 기록부로 만들기
- 에이전트 가시성이 목표다
- 아키텍처와 취향(품질 기준) 강제하기
- 처리량이 병합 철학을 바꾸는 방식
- “agent-generated”의 실제 의미
- 자율성 레벨 점진적 확대
- 엔트로피와 가비지 컬렉션
- 아직 배우는 중인 점

## Engineering

# Harness engineering: 에이전트 우선 시대에서 Codex를 활용하는 방법

by Ryan Lopopolo, Member of the Technical Staff

지난 5개월간 우리 팀은 실험을 진행했다. 수동으로 직접 작성한 코드 0줄로 소프트웨어 제품의 내부 베타를 만들고 배포했다.

그 제품은 내부 일일 사용자와 외부 알파 테스터를 보유하고 있으며, 배포되고, 동작하고, 깨지고, 다시 고쳐졌다. 차별점은 모든 코드 라인이 Codex가 작성했다는 점이다. 여기에는 앱 로직, 테스트, CI 구성, 문서, 관측성(observability), 내부 도구까지 포함된다. 우리는 이를 수동 작성에 비해 대략 10배 적은 시간으로 완성했다고 추정한다.

사람은 조정하고, 에이전트는 실행한다.

우리는 의도적으로 이런 제약을 둬서, 엔지니어링 속도를 수십 배 올릴 수 있는 것을 만들기 위해 필요한 변화를 파악했다. 우리에게는 100만 라인 규모의 코드를 몇 주 만에 만들어야 하는 과제가 주어졌다. 이를 위해 팀의 주업무가 코드 작성이 아니라, 환경 설계·의도 명시·신뢰성 있는 결과를 내는 피드백 루프 구축으로 바뀌었을 때 무엇이 달라지는지를 이해해야 했다.

이 글은 에이전트들로 완전히 새 제품을 만들면서 배운 점(무엇이 깨졌는지, 무엇이 누적되어 개선됐는지), 그리고 가장 희소한 자원인 사람의 시간과 주의를 어떻게 극대화했는지를 정리한다.

## 빈 깃 저장소에서 시작하기

첫 커밋은 2025년 8월 말에 빈 저장소에 날아들었다.

초기 골격(저장소 구조, CI 구성, 포맷 규칙, 패키지 매니저 설정, 애플리케이션 프레임워크)은 GPT‑5로 가이드를 받은 기존 템플릿을 바탕으로 Codex CLI로 생성됐다. 저장소에서 에이전트가 어떻게 일해야 하는지 지시하는 최초의 `AGENTS.md` 파일도 Codex가 작성했다.

시작점은 사람이 쓴 기존 코드가 전혀 없었다. 처음부터 저장소는 에이전트의 형태로 형성됐다.

5개월 뒤, 저장소에는 애플리케이션 로직, 인프라, 도구, 문서, 내부 개발 유틸리티를 합쳐 대략 백만 줄 규모의 코드가 쌓여 있었다. 이 기간 동안 총 1,500건 정도의 PR이 열리고 병합되었고, 이때 실제로 Codex를 주도한 엔지니어는 3명에 불과했다. 이는 엔지니어 1명당 평균 3.5개 PR/일의 처리량에 해당한다. 놀랍게도 팀이 7명으로 늘어나도 처리량은 오히려 늘어났다. 중요하게도 이 성과는 단순 수치 경쟁이 아니라, 매일 사용하는 내부 사용자가 수백 명인 실제 제품에 기반한 성과다.

개발 전 과정에서 사람은 직접 코드를 기여하지 않았다. 이 점이 팀의 핵심 철학이 되었다: 수동 작성 코드는 없다.

## 엔지니어 역할의 재정의

손으로 코딩하지 않는 조건은 다른 종류의 엔지니어링 일을 만들었다. 더 이상 구현 자체가 중심이 아니라, 시스템, 스캐폴딩, 레버리지 설계가 핵심이 되었다.

초기 진척은 예상보다 느렸지만, 이는 Codex의 능력 부족이 아니라 환경이 덜 명세되어 있었기 때문이었다. 에이전트는 목적 달성에 필요한 도구, 추상화, 내부 구조가 부족해 제약을 만났다. 결과적으로 팀의 핵심 임무는 “유용한 일”을 하도록 에이전트를 가능하게 만드는 일이 됐다.

실무적으로는 깊이 우선으로 접근했다. 큰 목표를 작은 블록(설계, 코드, 리뷰, 테스트 등)으로 쪼개고, 에이전트가 그 블록을 만들도록 프롬프트를 주고, 다시 이를 더 큰 문제의 출발점으로 쓰는 방식이다.

문제가 생기면 답은 거의 “더 열심히 시도해라”가 아니다. 에이전트를 통해만 진전할 수 있었기 때문에, 인간 엔지니어는 항상 개입해 “어떤 능력이 빠졌고, 그것을 에이전트가 보기 쉽고 강제 가능하게(legible하고 enforceable) 만들려면 무엇이 필요한가”를 묻는 방식이었다.

사람은 거의 전적으로 프롬프트로 시스템과 상호작용한다. 엔지니어가 작업을 말하고 에이전트를 실행해 PR을 열도록 둔다. PR을 마무리하려면, 에이전트가 자체 변경을 로컬에서 리뷰하고, 추가로 특정 에이전트 리뷰를 로컬 및 클라우드에서 요청하고, 사람이든 에이전트든 주어진 피드백을 반응적으로 처리한 뒤 모든 리뷰어가 만족할 때까지 반복하게끔 지시한다. 이는 사실상 `Ralph Wiggum Loop`를 반복한다는 뜻이다(원문: Ralph Wiggum Loop).

Codex는 표준 개발 도구(gh, 로컬 스크립트, 저장소에 내장된 스킬)를 직접 써서 문맥을 수집한다. 즉 사람에게 복사·붙여넣기할 필요가 없다.

사람이 PR을 리뷰할 수도 있지만 필수는 아니다. 시간이 지나면서 거의 모든 리뷰를 에이전트 대 에이전트로 넘길 수 있었다.

## 애플리케이션 가시성(legibility) 높이기

코드 처리량이 늘자 병목은 사람의 QA 용량이 됐다. 사람의 시간과 주의가 고정되어 있었기 때문에, 우리는 에이전트가 앱 UI, 로그, 메트릭 자체를 직접 이해할 수 있도록 만들었다.

예를 들어, 변경 하나당 하나의 인스턴스를 실행할 수 있게 git worktree별 부팅이 가능하도록 했다. 또한 Chrome DevTools Protocol을 에이전트 런타임에 연결하고 DOM 스냅샷·스크린샷·내비게이션용 스킬을 만들었다. 덕분에 Codex가 버그를 재현하고 수정사항을 검증하며 UI 동작을 직접 추론할 수 있게 됐다.

또한 관측성도 같은 방식으로 확장했다. 로그, 메트릭, 트레이스를 각 작업 트리워크(worktree) 기준의 임시 로컬 관측성 스택에 노출한다. Codex는 완전히 분리된 앱 인스턴스에서 작업을 수행하는데, 이는 작업 완료 시 해당 로그·메트릭도 함께 정리되는 구조다. 에이전트는 LogQL로 로그, PromQL로 메트릭을 조회한다.

이 정도 맥락이 쌓이면 “서비스 시작은 800ms 미만이어야 한다” 또는 “네 개 핵심 사용자 여정의 어떤 span도 2초를 넘지 말 것” 같은 지시가 현실적인 제약으로 작동한다.

`img` 캡션: Codex가 Chrome DevTools MCP를 통해 작업을 직접 검증하는 구조.

`img` 캡션: 로컬 개발에서 로그·메트릭·트레이스를 벡터(=Vector)로 흘리고, Victoria Logs/metrics/traces로 라우팅한 뒤 코드 수정·재기동·재검증을 반복하는 구조.

우리는 단일 Codex 실행이 한 작업에 6시간 넘게 쓰이는 경우도 자주 본다(종종 인간이 잠든 시간대).

## 저장소 지식을 시스템 기록부로 만들기

맥락 관리가 큰 과제다. 대규모·복잡 작업에서 에이전트가 효과적으로 일하려면 핵심 교훈이 명확하다. 정답은 “거대한 설명서를 한 번에 던지는 것”이 아니라, 지도(map)를 주는 것이다.

우리는 초기에 “거대한 `AGENTS.md`” 방식으로 시작했으나 실패했다.

- 맥락은 희소자원이다. 아주 큰 지침 파일은 과제와 코드, 필요한 문서를 가리고 핵심 제약을 놓치게 하거나 잘못된 제약 최적화를 유발한다.
- 안내가 너무 많으면 안내가 아니게 된다. 모든 것이 중요하다고 쓰면 결국 아무 것도 중요하지 않게 된다.
- 내용이 즉시 낡는다. 거대한 매뉴얼은 규칙이 오래된 “폐기물 창고”가 된다. 에이전트는 어느 항목이 여전히 유효한지 구분 못 하고, 사람이 관리하기도 어렵다.
- 검증이 어렵다. 단일 덩어리 파일은 커버리지·최신성·소유권·상호링크 같은 기계적 검증이 어렵고, 그래서 드리프트가 생긴다.

그래서 `AGENTS.md`를 백과사전처럼 취급하지 않고, 목차로 축소했다.

저장소 지식 기반은 구조화된 `docs/` 디렉터리를 시스템 기록부로 둔다. 짧은 `AGENTS.md`(대략 100줄)만 맥락 진입점으로 주입하고, 더 깊은 진실의 근원은 별도 문서로 분기한다.

### 파일 구조 예시(평문)

	AGENTS.md
	ARCHITECTURE.md
	docs/
	  ├── design-docs/
	  │   ├── index.md
	  │   ├── core-beliefs.md
	  │   └── ...
	  ├── exec-plans/
	  │   ├── active/
	  │   ├── completed/
	  │   └── tech-debt-tracker.md
	  ├── generated/
	  │   └── db-schema.md
	  ├── product-specs/
	  │   ├── index.md
	  │   ├── new-user-onboarding.md
	  │   └── ...
	  ├── references/
	  │   ├── design-system-reference-llms.txt
	  │   ├── nixpacks-llms.txt
	  │   ├── uv-llms.txt
	  │   └── ...
	  ├── DESIGN.md
	  ├── FRONTEND.md
	  ├── PLANS.md
	  ├── PRODUCT_SENSE.md
	  ├── QUALITY_SCORE.md
	  ├── RELIABILITY.md
	  └── SECURITY.md

In-repository knowledge store 레이아웃

설계 문서는 카탈로그화되고 인덱싱된다. 검증 상태와 핵심 신념이 함께 담긴다. 에이전트 우선 운영 원칙을 정의하는 문서다.

`Architecture documentation`은 도메인과 패키지 계층의 상위 지도를 제공한다. `quality` 문서는 제품 도메인과 아키텍처 계층별로 격차를 시간별 추적한다.

플랜은 1급 산출물이다. 작은 변경은 가벼운 플랜으로 처리하고, 복잡한 작업은 실행 계획으로 깊게 남긴다. 진행과 결정 로그는 저장소에 함께 체크인한다. 활성 플랜·완료 플랜·기술 부채 상태를 버전 관리해서 에이전트가 외부 컨텍스트에 의존하지 않고도 작동하게 한다.

이로 인해 점진적 노출이 가능해진다. 에이전트는 초기에 작고 안정적인 진입점에서 시작하고, 필요 시 다음 위치를 안내받아 확장한다. 처음부터 과부하를 주지 않는다.

기계적으로도 강제한다. 전용 린터와 CI 작업으로 지식 베이스가 최신인지, 교차 링크가 맞는지, 구조가 맞는지 검증한다. 반복적으로 동작하는 `doc-gardening` 에이전트가 오래된 문서나 코드 동작과 맞지 않는 문서를 찾아 고쳐 달라고 PR을 열어 둔다.

에이전트 가시성 자체를 높이기 위해 더 많은 시스템을 에이전트가 직접 확인·검증·수정 가능한 형태로 두면, Codex뿐 아니라 다른 에이전트(Aardvark)까지의 효과가 늘어난다.

## 에이전트 가시성이 목표다

코드베이스가 성숙해지면서 Codex의 설계 판단 프레임도 진화해야 했다.

코드가 완전 에이전트 생성 방식이어서, 우선 Codex 가시성에 최적화된 형태가 된다. 신입 엔지니어가 코드를 빠르게 읽을 수 있게 네비게이션을 개선하는 것과 유사하게, 인간 엔지니어의 목표는 저장소 자체만으로 에이전트가 도메인 전체를 직접 추론할 수 있게 하는 것이다.

에이전트 관점에서 보면, 실행 중 컨텍스트에서 접근하지 못하는 것은 사실상 존재하지 않는다. 구글 문서, 채팅 스레드, 사람의 기억 속 지식은 시스템에서 보지 못한다. 저장소 로컬의 버전 관리 산출물(코드, 마크다운, 스키마, 실행 가능한 플랜)만이 볼 수 있는 세계다.

이해했을 때 더 많이 배운 점은 맥락을 저장소로 계속 끌어들여야 한다는 것이다. 팀 정렬을 위한 Slack 대화를 에이전트가 알 수 없다면, 3개월 뒤 신입이 모르는 정보와 같은 상태가 된다.

Codex에 더 많은 맥락을 주려면, 이를 적절히 정리해 과잉 지시를 피하고 접근성을 높여야 한다. 새 동료를 제품 원칙·엔지니어링 규범·팀 문화(이모지 선호 포함)로 온보딩하듯이, 에이전트에게도 이런 정보를 주면 출력 정합성이 좋아진다.

이 프레임은 여러 트레이드오프를 정리해줬다. 내부화 가능한 의존성과 추상화를 우선했다. “재밌는 최신 기술”보다 조합 가능성, API 안정성, 학습 데이터에서의 표현력 관점에서 “평범해 보이는 기술”이 에이전트에게 오히려 이해하기 쉬운 경우가 많았다. 어떤 경우에는 공개 라이브러리 동작이 불투명해서 우회하는 비용이 더 컸고, 그 부분은 에이전트가 부분적으로 재구현하는 게 더 저렴했다.

예를 들어, 일반적인 `p-limit` 류 패키지를 무조건 가져오기보다, OpenTelemetry 계측과 완전히 통합되고 100% 테스트 커버리지를 가진 자체 동시성 맵핑 유틸을 직접 만들었다.

## 아키텍처와 취향(품질 기준) 강제하기

문서만으로는 에이전트 생성 코드베이스의 일관성을 유지할 수 없다. 구현을 일일이 간섭하지 않고 불변식(invariant)을 강제함으로써 에이전트가 빠르게 배포할 수 있게 하면서도 기초를 무너뜨리지 않는다.

예로, Codex에 `parse data shapes at the boundary`를 요구했다(원문: parse data shapes at the boundary). 구현 방식은 강제하지 않는다(모델이 Zod를 선호할 때가 있었지만 특정 라이브러리를 지정하지는 않았다).

에이전트는 예측 가능한 구조와 엄격한 경계에서 가장 잘 작동한다.
그래서 앱 전체를 고정된 아키텍처 모델로 구성했다. 각 도메인을 정해진 계층으로 분할하고, 의존 방향과 허용되는 엣지를 엄격히 검증한다. 이 제약은 커스텀 린터와 구조 테스트로 기계적으로 강제한다.

아래 다이어그램처럼, 각 도메인에서(App Settings 같은) 코드는 `Types → Config → Repo → Service → Runtime → UI`로만 전방향 의존한다.

크로스 컷팅 요구사항(인증, 커넥터, 텔레메트리, 기능 플래그)은 오직 `Providers`라는 단일 인터페이스로만 들어온다. 그 밖의 진입은 허용되지 않으며, 기계적으로 막는다.

이런 방식은 수백 명 엔지니어가 있어야 가능한 아키텍처처럼 보이지만, 코딩 에이전트에서는 초기에 갖춰야 하는 필수 조건이다. 제약이 쌓아야 속도가 유지되고 아키텍처 붕괴를 막을 수 있다.

현실적으로는 커스텀 린터·구조 테스트와 함께 `taste invariants`를 둔다. 예를 들어 구조화 로깅, 스키마·타입 명명 규칙, 파일 크기 제한, 플랫폼별 신뢰성 요구사항을 정적 검증한다. 린터의 에러 메시지를 에이전트 컨텍스트에 대체안까지 넣도록 작성한다.

사람 중심 워크플로였다면 이런 규칙이 과하게 느껴질 수 있다. 하지만 에이전트 환경에서는 오히려 배율이 생긴다. 한 번 인코딩되면 전역으로 즉시 적용되기 때문이다.

동시에 어디까지 제한하고 어디까지 풀어둘지 구분한다. 대규모 플랫폼 조직에서 보듯 중앙에서 경계와 정합성을 지키고, 로컬에서는 자율성을 허용한다.

결과물은 사람이 선호하는 스타일과 항상 일치하진 않는다. 하지만 정답은 정확성·유지보수성·앞으로의 에이전트 실행에서의 가독성이라면 통과이다.

인간의 취향은 시스템에 계속 피드백된다. 리뷰 코멘트, 리팩터링 PR, 사용자 면상 버그는 문서 업데이트나 도구 반영으로 들어간다. 문서가 부족하면 룰을 코드로 승격한다.

## 처리량이 병합 철학을 바꾸는 방식

Codex 처리량이 늘자 기존 엔지니어링 규범이 역효과를 냈다.

저장소는 최소한의 병합 게이트로 운영한다. PR은 짧은 수명으로 두고, 테스트 플래이크는 즉시 막는 대신 후속 실행으로 처리한다. 에이전트 처리량이 사람 주의 대비 훨씬 클 때, 오히려 대기 자체가 비용이 되므로, 수정은 빠르게 반복하는 쪽이 효율적이다.

낮은 처리량 환경에서는 이런 방식이 위험할 수 있지만, 여기서는 유효한 트레이드오프다.

## “agent-generated”의 실제 의미

우리가 코드베이스를 Codex 에이전트가 만든다고 말할 때, 이는 코드베이스의 “모든 것”을 뜻한다.

에이전트가 만드는 것:

- 제품 코드와 테스트
- CI 구성과 릴리스 도구
- 내부 개발 도구
- 문서와 설계 이력
- 평가용 하네스(evaluation harness)
- 리뷰 코멘트와 응답
- 저장소 자체를 관리하는 스크립트
- 운영 대시보드 정의 파일

사람은 여전히 루프 안에 있지만, 예전과는 다른 추상화 계층에서 일한다. 우리는 우선순위를 정하고 사용자 피드백을 수용 기준으로 바꿔 번역해내며 결과를 검증한다. 에이전트가 막히면, 단순히 더 명령을 주는 게 아니라 부족한 것이 도구인지, 안전장치인지, 문서인지 찾아서 저장소에 다시 반영한다. 이때도 수정은 Codex가 직접 작성한다.

에이전트는 표준 개발 도구로 직접 리뷰 피드백을 가져오고, 인라인으로 응답하고, 업데이트를 푸시하고, 종종 자신이 만든 PR을 squash·merge한다.

## 자율성 레벨 점진적 확대

개발 루프가 검증·피드백 처리·복구까지 직접 저장소에 내장되자, 저장소는 최근 의미 있는 임계점을 넘어섰다. 이제 Codex가 새 기능을 엔드투엔드로 주도할 수 있게 됐다.

단일 프롬프트에서 에이전트가 할 수 있는 일:

- 코드베이스의 현재 상태 점검
- 리포트된 버그 재현
- 실패 장면을 기록한 비디오 생성
- 수정 구현
- 앱 실행으로 수정 검증
- 해결 후 두 번째 비디오 생성
- PR 열기
- 에이전트/인간 피드백 응답
- 빌드 실패 탐지 및 수정
- 판단이 필요한 경우에만 인간에게 에스컬레이션
- 변경 병합

이 동작은 이 저장소의 특정 구조와 도구에 크게 의존한다. 비슷한 성과를 일반화하려면 동등한 투자 없이는 어렵다. 아직은 그렇다.

## 엔트로피와 가비지 컬렉션

완전한 에이전트 자율성은 새로운 문제도 만들었다.

Codex는 저장소에 이미 있는 패턴—even 부정확하거나 최적이 아닌 패턴—을 그대로 복제한다. 시간이 지나면 드리프트가 누적된다.

초기엔 사람이 수동으로 해결했다. 팀은 매주 금요일마다(주 20%) “AI slop” 정리에 시간을 썼지만, 이는 확장되지 못했다.

대신 `golden principles`(원문: golden principles)라고 부르는 규칙들을 저장소에 직접 넣고, 정기적 정리 프로세스를 만들었다. 이 규칙들은 다음 실행에서 코드 가독성과 일관성을 유지하도록 기계적으로 강제되는 항목들이다.

예를 들어:

1. 공통 유틸리티 패키지를 선호해 불변식을 중앙집중화한다.
2. YOLO 방식의 데이터 추측 접근을 금지하고 경계 검증이나 타입 SDK 기반 접근을 선호해, 에이전트가 추측형 스키마에 기대지 못하게 한다.

주기적으로 Codex 백그라운드 작업이 오차를 스캔해 품질 점수를 갱신하고, 타깃 리팩터링 PR을 열어 수정한다. 대부분 1분 이내 리뷰할 수 있고 자동 병합도 가능하다.

이는 마치 가비지 컬렉션이다. 기술 부채는 고금리 대출과 같아서, 큰 충격으로 한 번에 해결하기보다 작은 단위로 지속적으로 줄이는 게 효율적이다. 인간의 취향은 한 번 확정되면 모든 코드 라인에 계속 강제 적용되어, 나쁜 패턴이 며칠·수주 동안 퍼지는 걸 막는다.

## 아직 배우는 중인 점

이 전략은 내부 출시와 OpenAI 내 채택을 지나 꽤 잘 작동했다. 실제 사용자용 제품을 만들며 현실에 기반한 투자 판단을 할 수 있었고, 장기 유지보수 가능성에 닻을 걸 수 있었다.

아직 모르는 건 아직 남아 있다.
완전 에이전트 생성 시스템에서 수년 단위로 아키텍처 정합성이 어떻게 진화하는지 정확히 모른다.
우리가 사람의 판단력을 가장 잘 살릴 지점과 그것을 시스템에 어떻게 축적해 누적시킬지 또한 학습 중이다.
또한 모델이 계속 성능이 높아질수록 이 시스템이 어떻게 진화할지도 아직 미지수다.

우리가 분명히 본 것은 이렇다.
소프트웨어 개발은 여전히 규율을 요구한다. 다만 규율이 코드 자체보다 스캐폴딩에서 더 크게 드러난다.
도구, 추상화, 피드백 루프가 코드의 일관성 유지를 좌우한다.

현재 가장 어려운 과제는 에이전트가 우리의 목표를 달성하도록 돕는 환경·피드백 루프·제어 시스템을 설계하는 것이다. 즉 복잡하고 신뢰 가능한 소프트웨어를 대규모로 만들고 유지하기 위해서다.

Codex 같은 에이전트가 소프트웨어 생명주기의 더 큰 부분을 맡게 되면, 이런 질문이 더 중요해진다. 이 초기 교훈을 공유해 여러분이 어디에 노력을 투자해야 “그냥 만들기”로 이어질 수 있는지를 판단하는 데 도움이 되길 기대한다.

## Author

Ryan Lopopolo

## Acknowledgements

특별 감사: Victor Zhu, Zach Brock(기여), 그리고 이 새 제품을 만든 전 팀.

## Keep reading

- [Beyond rate limits: scaling access to Codex and Sora][1] (이 글은 OpenAI, 2026-02-13)
- [Unlocking the Codex harness: how we built the App Server][2] (이 글은 OpenAI, 2026-02-04)
- [Inside OpenAI’s in-house data agent][3] (이 글은 OpenAI, 2026-01-29)

[1]:	https://openai.com/index/beyond-rate-limits/
[2]:	https://openai.com/index/unlocking-the-codex-harness/
[3]:	https://openai.com/index/inside-our-in-house-data-agent/