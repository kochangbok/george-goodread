{
  "items": [
    {
      "id": "admin-1771855456685",
      "title": "Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까",
      "category": "ai",
      "type": "article",
      "source": "블로그",
      "sourceUrl": "https://minusx.ai/blog/decoding-claude-code/",
      "summary": "# reddit 유저의 클로드 코드 6개월 사용 후기\n\n- 원문 링크: https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/\n- 저자: JokeGold5455\n- 출처: www.reddit.com\n\n# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까\n\n원문 링크: https://minusx.ai/blog/decoding-claude-code/?utm_source=tldrnewsletter\n\n원문 서명/출처: vivek (@nuwandavek), MinusX\n\n## 이미지 설명\n- Claude Code 업데이트 차이를 선명하게 확인할 수 있음\n\n# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까\n\n/ [vivek](https://x.com/nuwandavek) / 2025-08-21\n\nClaude Code는 지금까지 내가 써 본 AI 에이전트/워크플로우 중 가장 쓰기 편한 도구다. 타깃 편집이나 즉흥적인 vibe 코딩에 쓰는 도구보다 단순히 덜짜증나는 수준을 넘어, 실제로 쓰는 사람이 만족감을 느끼게 만든다. 강력한 자율성으로 꽤 많은 일을 시킬 수 있으면서도, 다른 일부 도구들처럼 “제어권을 잃는 듯한” 이질감은 덜 준다. 물론 핵심적인 작업량은 최신 Claude 4 모델(특히 interleaved thinking, `문맥을 반씩 번갈아가며 판단하는 방식`(원문: \"interleaved thinking\")이) 덕분이다.\n\n동일 모델을 쓰는 Cursor나 GitHub Copilot 에이전트와 비교해도, Claude Code는 상대적으로 덜 번거롭게 느껴진다. 왜 이렇게까지 좋다고 느꼈을까? 이 글을 읽고 고개가 끄덕여진다면, 그 이유를 정리해보려 한다.\n\n참고: 이것은 Claude Code의 내부 구조를 공개하는 글이 아니다. 그 같은 글은 이미 충분히 존재한다. 이 글은 몇 달간의 직접 사용과 실측 로그 분석을 바탕으로, ‘쓸 만한 LLM 에이전트’를 만들기 위한 실무 가이드이다. 부록에서 프롬프트와 도구를 볼 수 있다. 약 2천 단어 분량이므로, 짧게 보려면 TL;DR부터 보는 게 좋다.\n\n이미지: prompts\n\nClaude Code의 업그레이드 흐름이 분명히 보임\n\nClaude Code(이하 CC)는 직관적으로 잘 동작한다. 이는 단순히 사용자 경험이 좋다는 뜻이 아니라, LLM이 잘하는 일과 못하는 일을 명확히 반영해 설계했기 때문이다. 프롬프트와 도구가 모델의 약점을 가리고 강점을 부각한다. 그래서 제어 루프가 매우 단순하고 디버깅하기 쉽다.\n\nMinusX에서는 공개 직후 바로 CC를 도입했다. 내부에서 덮어쓰기 없이 네트워크 요청을 가로채고 기록하는 로거를 만들어 분석 기반으로 사용했고, 아래 내용은 마지막 몇 개월간 집중 사용한 결과다. 이 글의 핵심 질문은 바로 이것이다. “Claude Code가 왜 그렇게 좋은가? 내 채팅형 LLM 에이전트에서도 같은 경험을 만들 수는 없을까?” 현재 대부분을 MinusX에 반영했고, 독자도 그대로 적용해보길 권한다.\n\n이미지: prompts\n\n가장 빈번하게 쓰이는 도구 순서는 Edit → Read → ToDoWrite였다.\n\n## Claude Code형 에이전트를 만드는 법: TL;DR\n\n한마디로 정리하면 이렇다. **복잡하게 가지 말고 핵심만 유지해야 한다**(원문: “Keep Things Simple, Dummy”). (역자 주. “dummy”는 비격식적 강조어라 직역보다 ‘핵심 단순화’로 의역했다.)\n\nLLM은 디버깅과 평가 자체가 어렵다. 여기에 멀티에이전트, 에이전트 인계 구조, 복잡한 RAG 검색 알고리즘 같은 추가 복잡성을 더하면 문제 해결이 10배 더 어려워진다. 겉보기엔 잘 돌아가는 취약한 시스템도, 한 번 돌아가기 시작하면 나중에 구조를 바꾸는 게 공포로 다가온다. 그래서 가능한 한 하나의 파일에 핵심을 두고, 과도한 보일러플레이트는 반복적으로 제거하는 게 낫다.\n\nClaude Code에서 가져갈 핵심 정리:\n\n### 1. 제어 루프\n- 1.1 한 개의 메인 루프(최대 한 갈래 분기)와 하나의 메시지 이력 유지\n- 1.2 거의 모든 단계에서 소형 모델 사용\n\n### 2. 프롬프트\n- 2.1 claude.md 패턴으로 사용자 선호를 공유·기억\n- 2.2 특수 XML 태그, Markdown, 그리고 풍부한 예시\n\n### 3. 도구\n- 3.1 LLM 기반 검색이 RAG 기반 검색보다 우선\n- 3.2 좋은 도구 설계(고수준 vs 저수준)\n- 3.3 에이전트가 자기 todo 목록을 직접 관리\n\n### 4. 조정 가능성(steerability)\n- 4.1 말투와 스타일\n- 4.2 “PLEASE THIS IS IMPORTANT”류의 강조 표현이 여전히 현실적인 조정 수단\n- 4.3 규칙을 나열하기보다 알고리즘·휴리스틱·예시로 설명\n\n> Claude Code는 아키텍처 수준에서 단순함을 택한다. 하나의 메인 루프, 간단한 검색, 단순한 todo 목록 등을 유지한다. 과도한 설계 대신 잘 제어된 실험 환경을 만들어 모델이 스스로 ‘요리’하게 두는 방식이다.\n> (원문: “Is this end-to-end self-driving all over again? Bitter lesson much?”)\n\n---\n\n## 1. 제어 루프 설계\n\n### 1.1 하나의 메인 루프만 유지\n\n디버깅 가능성은 다단계 다중 에이전트 구성을 넘는다.\n\n멀티 에이전트가 유행인 시대에도 CC는 실제로 하나의 메인 스레드만 유지한다. 필요한 경우에만, git 히스토리를 요약하거나 메시지 이력을 하나로 압축하거나 UX 장식을 구성하는 특수 프롬프트를 주기적으로 사용한다. 다만 전반적으로는 평평한(flat) 메시지 목록을 유지한다.\n\n계층형 작업 처리 또한 독특하게 접근한다. 추가 하위 에이전트를 생성하되, 새 하위 에이전트가 또다시 하위 에이전트를 만들 수는 없다.\n\n최대 한 갈래의 분기만 허용되고, 그 결과는 `tool response` 형태로 메인 메시지 이력에 반영된다.\n\n문제가 단순하면 메인 루프는 반복적인 도구 호출로 처리한다. 하지만 작업이 하나 이상의 복합 문제일 경우, 메인 에이전트가 자기 자신을 복제해 분기한다. 최대 한 갈래 제한과 todo 목록을 같이 쓰면, 문제를 하위 작업으로 나누되 최종 목표를 계속 바라볼 수 있다.\n\n내가 보기엔 다중 에이전트 구조가 꼭 필요할 가능성은 낮다. 추상화 계층이 늘어날수록 디버깅 난이도는 올라가고, 무엇보다 모델의 일반적 성능 개선 흐름에서 멀어질 수 있다.\n\n이미지: Control Loop\n\n### 1.2 모든 일에 작은 모델 사용\n\nCC의 주요 LLM 호출의 50% 이상이 claude-3-5-haiku로 처리되었다. 이 모델은 대용량 파일 읽기, 웹 페이지 파싱, git 히스토리 처리, 긴 대화 요약 같은 일에 쓰이며, 매 입력마다 1단어 처리 라벨을 생성하는 데까지 활용된다(`one-word processing label`, 원문: \"for every key stroke\").\n\n소형 모델은 Sonnet 4, GPT-4.1 같은 표준 모델 대비 70~80% 저렴하다. 과감히 써야 한다.\n\n## 2. 프롬프트\n\nClaude Code는 상당히 정교한 프롬프트를 사용한다. 휴리스틱, 예시, 그리고 IMPORTANT(원문: \"IMPORTANT\") 형태의 리마인더가 빈번하다. 시스템 프롬프트는 약 2800 토큰이며, 도구 설명은 약 9400 토큰 수준이다. 사용자 프롬프트에는 대개 claude.md가 들어가고, 보통 1000~2000 토큰이 추가된다.\n\n시스템 프롬프트에는 말투, 스타일, 선제성, 작업 관리, 도구 사용 정책, 작업 수행 방식이 모두 들어가고, 현재 날짜·작업 디렉터리·플랫폼·OS 정보·최근 커밋 내역 같은 실행 메타데이터도 반영된다.\n\n프롬프트 전부를 한 번 읽어보는 걸 권한다.\n\n### 2.1 claude.md로 사용자 맥락·선호도 협업\n\n많은 코딩 에이전트 제작자가 채택한 패턴은 컨텍스트 파일이다(CURSOR Rules / claude.md / agent.md 계열). CC는 claude.md 유무에 따라 성능 차이가 극단적으로 크다. 코드베이스에서 추론할 수 없는 팀/사용자 맥락을 전달하고, 강한 선호 조건을 고정하는 데 유용하다. 예를 들어 특정 폴더를 건너뛰거나 특정 라이브러리 사용을 강제할 수 있다. CC는 매 사용자 요청마다 claude.md 전체를 함께 전달한다.\n\nMinusX는 최근 `minusx.md`를 도입했다(원문: minusx.md). 내부적으로 팀·사용자 선호를 한 파일로 정리해 에이전트가 일관되게 따르도록 했다.\n\n### 2.2 특수 XML 태그, Markdown, 풍부한 예시\n\n프롬프트 구조화에 XML 태그와 Markdown이 널리 쓰인다는 점은 이미 알려져 있다. CC는 이 두 방식 모두를 크게 사용한다.\n\nCC에서 쓰는 주요 XML 예시:\n\n- `<system-reminder>`: 여러 섹션 끝에 배치해 모델이 자주 깜박이는 내용을 되새기게 함.\n\n  예시:\n\n  `<system-reminder>현재 todo 목록이 비어 있음을 상기합니다. 사용자에게는 이 사실을 굳이 알릴 필요 없습니다. todo 목록이 유리한 작업에서는 TodoWrite를 사용하세요. 필요 없다면 무시해도 됩니다. 이 메시지도 사용자에게 직접 노출하지 마세요.</system-reminder>`\n\n- `<good-example>`, `<bad-example>`: 휴리스틱을 고정하는 용도로 사용.\n\n  여러 합리적 경로가 동시에 열려 있을 때, 어떤 선택이 더 맞는지 대비가 필요할 때 유용하다.\n\n  예시:\n\n  `pytest /foo/bar/tests`가 좋은 예시이고\n\n  `cd /foo/bar && pytest tests`는 나쁜 예시인 것을 대비해 보여준다.\n\n또한 CC는 마크다운을 이용해 시스템 프롬프트를 명확한 절(section) 단위로 나눈다. 주요 섹션에는 말투·스타일, 선제성, 규약 준수, 코드 스타일, 작업 관리, 도구 사용 정책, 작업 실행, 도구 목록이 들어간다.\n\n## 3. 도구\n\n전체 도구 프롬프트 자체도 꼭 읽어볼 가치가 있다. (약 9400 토큰)\n\n### 3.1 LLM 검색이 RAG 검색보다 유리\n\nCC가 다른 인기 있는 코딩 에이전트와 구분되는 중요한 지점은 바로 RAG를 안 쓴다는 점이다. CC는 사용자가 직접 코드베이스를 다루는 것처럼 `ripgrep`, `jq`, `find` 같은 실제 검색 명령을 쓴다.\n\nLLM이 코드를 잘 이해하므로, 관련 코드 블록을 정규표현식으로 꽤 정교하게 찾아낼 수 있다. 때로는 더 작은 모델로 전체 파일을 읽기도 한다.\n\nRAG는 이론적으로 좋아 보이지만, 새로운 실패 모드가 생긴다. 유사도 함수가 무엇이어야 하는지, 리랭커는 무엇을 써야 하는지, 청크 단위는 어떻게 할지, 큰 JSON/로그를 어떻게 처리할지 등 판단 포인트가 많다.\n\nLLM 검색은 반면 간단히 JSON에서 10줄을 읽어 구조를 파악하고, 필요하면 10줄씩 더 보는 식으로 동작한다. 무엇보다 학습 가능한(RL learnable) 구조라는 점이 장점이다. (원문: “RL learnable”).\n\n무거운 모델 두 개를 엮는 구조보다 훨씬 단순하다. 또한 복잡한 고도형 구조를 이중으로 얽히게 두는 건 유지보수 측면에서도 거추장스럽다. (원문: “Camera vs Lidar” 비유는 두 기술 접근의 대비를 농담으로 강조한 것)\n\n작가가 농담처럼 언급했듯, LLM 시대의 `Camera vs Lidar` 구도가 떠오른다(원문: “Camera vs Lidar of the LLM era”). 즉 완전히 극단적 이분법은 아니고, 반은 농담, 반은 진심에 가깝다. (역자 주. Lidar는 거리측정 센서, Camera는 저비용·저정밀 방식의 은유로 이해하면 된다.)\n\n### 3.2 좋은 도구 설계: 저수준 vs 고수준\n\n‘에이전트에 어떤 도구를 줘야 하나’는 만드는 사람이라면 밤잠을 설칠 수 있는 고민이다. 높은 수준의 의미 기반 작업을 주는가, 아니면 키보드 타이핑·클릭처럼 저수준을 주는가.\n\n정답은 상황에 따라 다르고, 둘 다 써야 한다.\n\nCC는 저수준(Bash, Read, Write), 중간(Edit, Grep, Glob), 고수준(Task, WebFetch, exit_plan_mode) 도구를 모두 둔다.\n\nCC에 bash가 있으니 별도 Grep을 둘 필요가 없다는 의문이 들 수 있지만, 실제 사용 빈도를 보면 grep을 자주 쓰는 경향 때문에 따로 두는 편이 이득이다. 특수 상황에는 여전히 일반 bash 명령으로 처리한다.\n\nWebFetch, `mcp__ide__getDiagnostics`처럼 동작이 매우 결정적인 고수준 도구 역시 있다. 이는 모델이 저수준 입력/클릭 과정을 반복하는 비용을 줄여, 문제 해결 흐름을 덜 비틀리게 한다. 즉, 모델 부담을 줄여 주는 설계다.\n\n도구 설명은 구체적 예시를 많이 싣고, 같은 작업을 두 도구가 할 수 있을 때의 선택 기준까지 적어둔다.\n\nCC의 도구 목록:\n\n- Task\n- Bash\n- Glob\n- Grep\n- LS\n- ExitPlanMode\n- Read\n- Edit\n- MultiEdit\n- Write\n- NotebookEdit\n- WebFetch\n- TodoWrite\n- WebSearch\n- mcp__ide__getDiagnostics\n- mcp__ide__executeCode\n\n### 3.3 에이전트가 todo 목록 관리\n\n긴 실행 시간의 LLM 에이전트에서 맥락 붕괴(context rot)는 흔하다. 초반엔 어려운 문제를 잘 시작하다도, 시간이 지나면 정체가 무너져 쓰레기처럼 돌아가기도 한다.\n\n현재 에이전트들은 보통 명시적 todo를 실험한다: 한 모델이 todo를 만들고 다른 모델이 수행, 또는 PRD/PM → 구현 → QA의 다중 에이전트 승계 구조 같은 형태다.\n\n그러나 다중 에이전트 인계 자체가 좋은 선택은 거의 아니라고 저자는 본다. CC는 명시적인 todo 목록을 쓰되, 그 목록을 모델이 직접 유지한다. 모델은 todo를 자주 참조하라고 강하게 유도되고, 구현 중간에도 필요하면 새 항목을 추가하거나 기존 항목을 거절·수정하며 유연하게 경로를 바꾼다. 이는 `interleaved thinking`을 이용해 흐름을 즉시 조정하는 방식이다. (원문: \"interleaved thinking\")\n\n## 4. 조정 가능성(steerability)\n\n### 4.1 말투와 스타일\n\nCC는 에이전트의 ‘느낌 있는 동작’을 매우 의도적으로 통제한다. 시스템 프롬프트에는 말투, 스타일, 선제성 관련 섹션이 가득하며, 그것이 댓글 톤과 대응 태도까지 단정하게 만든다. 덕분에 코드 설명 없이도 정돈된 반응이 나온다.\n\n저자는 이 부분을 그대로 가져다 앱에 적용할 것을 권한다.\n\n예시:\n\n- IMPORTANT: 사용자 요청이 없으면 불필요한 머리말/꼬리말(예: 코드 설명 요약, 액션 요약)을 붙이지 말 것.\n- 요청하지 않은 기능 설명이나 정리도 기본적으로 생략.\n- 도와주지 못할 때는 이유를 늘어놓지 말 것(설교처럼 보이고 짜증 유발).\n- 이모지는 사용자가 분명히 요구하지 않으면 쓰지 말 것.\n\n### 4.2 “이건 중요합니다”류 표현이 아직은 최선의 조정 수단\n\n안타깝게도 모델이 “하지 말아야 할 일”을 따르게 만드는 건 여전히 어려운 편이다.\n\nIMPORTANT, VERY IMPORTANT, NEVER, ALWAYS 같은 키워드가 지금으로선 지뢰 구간을 피하게 만드는 데 가장 안정적이다. 미래엔 더 자연스럽게 조정 가능한 단계가 오겠지만, 지금은 이런 방식이 실용적이다.\n\n예시:\n\n- IMPORTANT: 사용자가 요청하지 않은 한 코멘트를 추가하지 말 것\n- VERY IMPORTANT: `find`, `grep`은 쓰지 말고 Grep, Glob, Task를 사용할 것\n- `cat`, `head`, `tail`, `ls`도 가능하면 배제하고 Read/LS를 사용할 것\n- 정말로 `grep`이 필요하면, `rg`부터 먼저 사용할 것\n- IMPORTANT: URL은 코딩 도움에 확신이 있을 때만 생성·추측\n\n### 4.3 알고리즘(휴리스틱+예시)로 작성\n\nLLM이 수행할 핵심 작업을 먼저 식별해, 그에 대한 알고리즘을 명시하는 게 핵심이다. 실제 모델처럼 역할 연기를 하며 예시를 여러 번 돌려 판단 지점을 모두 드러내면, 지시를 지키기 쉬워진다.\n\n큰 흐름도를 그리는 것도 유효한 방법이다. 이렇게 하면 의사결정이 구조화되고, 모델이 지시를 따라가기 쉬워진다.\n\n“수많은 해야 할 일 / 하면 안 되는 일” 목록을 한꺼번에 쓰면 유지보수가 어렵고 충돌이 생기기 쉽다. 프롬프트가 수천 토큰이면 충돌 규칙이 생겨 모델이 취약해진다.\n\nCC 시스템 프롬프트의 `Task Management`, `Doing Tasks`, `Tool Usage Policy` 항목은 이런 알고리즘을 구체적으로 제시하고, 수많은 상황별 휴리스틱·예시를 함께 제공한다.\n\n## Bonus: BigLab 프롬프트를 주의 깊게 보는 이유\n\nLLM 조정의 큰 비중은 사후 보정 데이터 분포(사실상 RLHF 경향)를 역추적하는 데 있다. JSON을 써야 하는지 XML을 써야 하는지, 도구 설명을 시스템 프롬프트에 넣을지 도구 정의로 둘지, 앱의 현재 상태는 어떻게 다룰지 같은 문제는 타사 구현을 보는 게 도움이 된다.\n\nCC의 설계는 매우 강한 운영 철학(`opinionated` 경향)을 갖고 있고, 이를 참고해 내 시스템을 고치는 게 효과적이다.\n\n## 결론\n\n핵심은 여전히 단순함이다. 과도한 프레임워크와 외부 확장은 오히려 역효과가 날 수 있다. CC를 통해 “에이전트는 단순해도 충분히 강력할 수 있다”는 믿음을 얻었고, MinusX에서도 그 교훈을 계속 반영하고 있다.\n\n자신만의 LLM 에이전트를 Claude식으로 정형화하고 싶다면, 저자는 대화나 공유를 환영한다고 밝혔다. 훈련 가능한 데이터 에이전트를 원한다면 MinusX를 참고하거나 데모를 신청하라.\n\nHappy (Claude) Coding!\n\n---\n\n## 부록\n\n- 메인 Claude Code 시스템 프롬프트 보기\n- 전체 Claude Code 도구 보기\n\n## 관련 글\n\n- [블로그 글 목록 보기](https://minusx.ai/blog/)\n- [Metabase AI](https://minusx.ai/metabase-ai/)\n- [요금제 보기](https://minusx.ai/pricing/)\n\n## 페이지 하단(번역)\n\n최신 업데이트 알림 구독을 위해 이메일 주소를 입력해 구독할 수 있다.\n이메일 주소\n구독\n\n연락: hi@minusx.ai\n\n© 2025 MinusX, Inc. 모든 권리 보유.\n\n### 제품\n\n- Chrome 확장 프로그램\n- Playground\n- GitHub\n- 문서\n\n### 기능\n\n- Metabase AI\n- MBQL AI Assistant\n- 대시보드 Q&A\n- 임베디드 AI\n\n### 회사\n\n- 요금제\n- 회사 소개\n- 블로그\n- 데모\n\n### 지원\n\n- 이용 약관\n- 개인정보 보호 정책\n- 신뢰 센터\n- 지원\n\n## 댓글 번역\n\n- 본문 소스에 공개 댓글 섹션이 없어 번역할 댓글 본문은 없습니다.",
      "filePath": "2026-02-23/minusx.ai-Claude_Code가_이렇게_뛰어난_이유__에이전트에서_그__마법_을_어떻게_재-1771855456685.md",
      "tags": [
        "ai",
        "클로드코드",
        "바이브코딩"
      ],
      "createdAt": "2026-02-23T14:04:16.685Z",
      "updatedAt": "2026-02-23T14:04:17.338Z"
    },
    {
      "id": "admin-1771855452152",
      "title": "Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까",
      "category": "ai",
      "type": "article",
      "source": "블로그",
      "sourceUrl": "https://minusx.ai/blog/decoding-claude-code/",
      "summary": "# reddit 유저의 클로드 코드 6개월 사용 후기\n\n- 원문 링크: https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/\n- 저자: JokeGold5455\n- 출처: www.reddit.com\n\n# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까\n\n원문 링크: https://minusx.ai/blog/decoding-claude-code/?utm_source=tldrnewsletter\n\n원문 서명/출처: vivek (@nuwandavek), MinusX\n\n## 이미지 설명\n- Claude Code 업데이트 차이를 선명하게 확인할 수 있음\n\n# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까\n\n/ [vivek](https://x.com/nuwandavek) / 2025-08-21\n\nClaude Code는 지금까지 내가 써 본 AI 에이전트/워크플로우 중 가장 쓰기 편한 도구다. 타깃 편집이나 즉흥적인 vibe 코딩에 쓰는 도구보다 단순히 덜짜증나는 수준을 넘어, 실제로 쓰는 사람이 만족감을 느끼게 만든다. 강력한 자율성으로 꽤 많은 일을 시킬 수 있으면서도, 다른 일부 도구들처럼 “제어권을 잃는 듯한” 이질감은 덜 준다. 물론 핵심적인 작업량은 최신 Claude 4 모델(특히 interleaved thinking, `문맥을 반씩 번갈아가며 판단하는 방식`(원문: \"interleaved thinking\")이) 덕분이다.\n\n동일 모델을 쓰는 Cursor나 GitHub Copilot 에이전트와 비교해도, Claude Code는 상대적으로 덜 번거롭게 느껴진다. 왜 이렇게까지 좋다고 느꼈을까? 이 글을 읽고 고개가 끄덕여진다면, 그 이유를 정리해보려 한다.\n\n참고: 이것은 Claude Code의 내부 구조를 공개하는 글이 아니다. 그 같은 글은 이미 충분히 존재한다. 이 글은 몇 달간의 직접 사용과 실측 로그 분석을 바탕으로, ‘쓸 만한 LLM 에이전트’를 만들기 위한 실무 가이드이다. 부록에서 프롬프트와 도구를 볼 수 있다. 약 2천 단어 분량이므로, 짧게 보려면 TL;DR부터 보는 게 좋다.\n\n이미지: prompts\n\nClaude Code의 업그레이드 흐름이 분명히 보임\n\nClaude Code(이하 CC)는 직관적으로 잘 동작한다. 이는 단순히 사용자 경험이 좋다는 뜻이 아니라, LLM이 잘하는 일과 못하는 일을 명확히 반영해 설계했기 때문이다. 프롬프트와 도구가 모델의 약점을 가리고 강점을 부각한다. 그래서 제어 루프가 매우 단순하고 디버깅하기 쉽다.\n\nMinusX에서는 공개 직후 바로 CC를 도입했다. 내부에서 덮어쓰기 없이 네트워크 요청을 가로채고 기록하는 로거를 만들어 분석 기반으로 사용했고, 아래 내용은 마지막 몇 개월간 집중 사용한 결과다. 이 글의 핵심 질문은 바로 이것이다. “Claude Code가 왜 그렇게 좋은가? 내 채팅형 LLM 에이전트에서도 같은 경험을 만들 수는 없을까?” 현재 대부분을 MinusX에 반영했고, 독자도 그대로 적용해보길 권한다.\n\n이미지: prompts\n\n가장 빈번하게 쓰이는 도구 순서는 Edit → Read → ToDoWrite였다.\n\n## Claude Code형 에이전트를 만드는 법: TL;DR\n\n한마디로 정리하면 이렇다. **복잡하게 가지 말고 핵심만 유지해야 한다**(원문: “Keep Things Simple, Dummy”). (역자 주. “dummy”는 비격식적 강조어라 직역보다 ‘핵심 단순화’로 의역했다.)\n\nLLM은 디버깅과 평가 자체가 어렵다. 여기에 멀티에이전트, 에이전트 인계 구조, 복잡한 RAG 검색 알고리즘 같은 추가 복잡성을 더하면 문제 해결이 10배 더 어려워진다. 겉보기엔 잘 돌아가는 취약한 시스템도, 한 번 돌아가기 시작하면 나중에 구조를 바꾸는 게 공포로 다가온다. 그래서 가능한 한 하나의 파일에 핵심을 두고, 과도한 보일러플레이트는 반복적으로 제거하는 게 낫다.\n\nClaude Code에서 가져갈 핵심 정리:\n\n### 1. 제어 루프\n- 1.1 한 개의 메인 루프(최대 한 갈래 분기)와 하나의 메시지 이력 유지\n- 1.2 거의 모든 단계에서 소형 모델 사용\n\n### 2. 프롬프트\n- 2.1 claude.md 패턴으로 사용자 선호를 공유·기억\n- 2.2 특수 XML 태그, Markdown, 그리고 풍부한 예시\n\n### 3. 도구\n- 3.1 LLM 기반 검색이 RAG 기반 검색보다 우선\n- 3.2 좋은 도구 설계(고수준 vs 저수준)\n- 3.3 에이전트가 자기 todo 목록을 직접 관리\n\n### 4. 조정 가능성(steerability)\n- 4.1 말투와 스타일\n- 4.2 “PLEASE THIS IS IMPORTANT”류의 강조 표현이 여전히 현실적인 조정 수단\n- 4.3 규칙을 나열하기보다 알고리즘·휴리스틱·예시로 설명\n\n> Claude Code는 아키텍처 수준에서 단순함을 택한다. 하나의 메인 루프, 간단한 검색, 단순한 todo 목록 등을 유지한다. 과도한 설계 대신 잘 제어된 실험 환경을 만들어 모델이 스스로 ‘요리’하게 두는 방식이다.\n> (원문: “Is this end-to-end self-driving all over again? Bitter lesson much?”)\n\n---\n\n## 1. 제어 루프 설계\n\n### 1.1 하나의 메인 루프만 유지\n\n디버깅 가능성은 다단계 다중 에이전트 구성을 넘는다.\n\n멀티 에이전트가 유행인 시대에도 CC는 실제로 하나의 메인 스레드만 유지한다. 필요한 경우에만, git 히스토리를 요약하거나 메시지 이력을 하나로 압축하거나 UX 장식을 구성하는 특수 프롬프트를 주기적으로 사용한다. 다만 전반적으로는 평평한(flat) 메시지 목록을 유지한다.\n\n계층형 작업 처리 또한 독특하게 접근한다. 추가 하위 에이전트를 생성하되, 새 하위 에이전트가 또다시 하위 에이전트를 만들 수는 없다.\n\n최대 한 갈래의 분기만 허용되고, 그 결과는 `tool response` 형태로 메인 메시지 이력에 반영된다.\n\n문제가 단순하면 메인 루프는 반복적인 도구 호출로 처리한다. 하지만 작업이 하나 이상의 복합 문제일 경우, 메인 에이전트가 자기 자신을 복제해 분기한다. 최대 한 갈래 제한과 todo 목록을 같이 쓰면, 문제를 하위 작업으로 나누되 최종 목표를 계속 바라볼 수 있다.\n\n내가 보기엔 다중 에이전트 구조가 꼭 필요할 가능성은 낮다. 추상화 계층이 늘어날수록 디버깅 난이도는 올라가고, 무엇보다 모델의 일반적 성능 개선 흐름에서 멀어질 수 있다.\n\n이미지: Control Loop\n\n### 1.2 모든 일에 작은 모델 사용\n\nCC의 주요 LLM 호출의 50% 이상이 claude-3-5-haiku로 처리되었다. 이 모델은 대용량 파일 읽기, 웹 페이지 파싱, git 히스토리 처리, 긴 대화 요약 같은 일에 쓰이며, 매 입력마다 1단어 처리 라벨을 생성하는 데까지 활용된다(`one-word processing label`, 원문: \"for every key stroke\").\n\n소형 모델은 Sonnet 4, GPT-4.1 같은 표준 모델 대비 70~80% 저렴하다. 과감히 써야 한다.\n\n## 2. 프롬프트\n\nClaude Code는 상당히 정교한 프롬프트를 사용한다. 휴리스틱, 예시, 그리고 IMPORTANT(원문: \"IMPORTANT\") 형태의 리마인더가 빈번하다. 시스템 프롬프트는 약 2800 토큰이며, 도구 설명은 약 9400 토큰 수준이다. 사용자 프롬프트에는 대개 claude.md가 들어가고, 보통 1000~2000 토큰이 추가된다.\n\n시스템 프롬프트에는 말투, 스타일, 선제성, 작업 관리, 도구 사용 정책, 작업 수행 방식이 모두 들어가고, 현재 날짜·작업 디렉터리·플랫폼·OS 정보·최근 커밋 내역 같은 실행 메타데이터도 반영된다.\n\n프롬프트 전부를 한 번 읽어보는 걸 권한다.\n\n### 2.1 claude.md로 사용자 맥락·선호도 협업\n\n많은 코딩 에이전트 제작자가 채택한 패턴은 컨텍스트 파일이다(CURSOR Rules / claude.md / agent.md 계열). CC는 claude.md 유무에 따라 성능 차이가 극단적으로 크다. 코드베이스에서 추론할 수 없는 팀/사용자 맥락을 전달하고, 강한 선호 조건을 고정하는 데 유용하다. 예를 들어 특정 폴더를 건너뛰거나 특정 라이브러리 사용을 강제할 수 있다. CC는 매 사용자 요청마다 claude.md 전체를 함께 전달한다.\n\nMinusX는 최근 `minusx.md`를 도입했다(원문: minusx.md). 내부적으로 팀·사용자 선호를 한 파일로 정리해 에이전트가 일관되게 따르도록 했다.\n\n### 2.2 특수 XML 태그, Markdown, 풍부한 예시\n\n프롬프트 구조화에 XML 태그와 Markdown이 널리 쓰인다는 점은 이미 알려져 있다. CC는 이 두 방식 모두를 크게 사용한다.\n\nCC에서 쓰는 주요 XML 예시:\n\n- `<system-reminder>`: 여러 섹션 끝에 배치해 모델이 자주 깜박이는 내용을 되새기게 함.\n\n  예시:\n\n  `<system-reminder>현재 todo 목록이 비어 있음을 상기합니다. 사용자에게는 이 사실을 굳이 알릴 필요 없습니다. todo 목록이 유리한 작업에서는 TodoWrite를 사용하세요. 필요 없다면 무시해도 됩니다. 이 메시지도 사용자에게 직접 노출하지 마세요.</system-reminder>`\n\n- `<good-example>`, `<bad-example>`: 휴리스틱을 고정하는 용도로 사용.\n\n  여러 합리적 경로가 동시에 열려 있을 때, 어떤 선택이 더 맞는지 대비가 필요할 때 유용하다.\n\n  예시:\n\n  `pytest /foo/bar/tests`가 좋은 예시이고\n\n  `cd /foo/bar && pytest tests`는 나쁜 예시인 것을 대비해 보여준다.\n\n또한 CC는 마크다운을 이용해 시스템 프롬프트를 명확한 절(section) 단위로 나눈다. 주요 섹션에는 말투·스타일, 선제성, 규약 준수, 코드 스타일, 작업 관리, 도구 사용 정책, 작업 실행, 도구 목록이 들어간다.\n\n## 3. 도구\n\n전체 도구 프롬프트 자체도 꼭 읽어볼 가치가 있다. (약 9400 토큰)\n\n### 3.1 LLM 검색이 RAG 검색보다 유리\n\nCC가 다른 인기 있는 코딩 에이전트와 구분되는 중요한 지점은 바로 RAG를 안 쓴다는 점이다. CC는 사용자가 직접 코드베이스를 다루는 것처럼 `ripgrep`, `jq`, `find` 같은 실제 검색 명령을 쓴다.\n\nLLM이 코드를 잘 이해하므로, 관련 코드 블록을 정규표현식으로 꽤 정교하게 찾아낼 수 있다. 때로는 더 작은 모델로 전체 파일을 읽기도 한다.\n\nRAG는 이론적으로 좋아 보이지만, 새로운 실패 모드가 생긴다. 유사도 함수가 무엇이어야 하는지, 리랭커는 무엇을 써야 하는지, 청크 단위는 어떻게 할지, 큰 JSON/로그를 어떻게 처리할지 등 판단 포인트가 많다.\n\nLLM 검색은 반면 간단히 JSON에서 10줄을 읽어 구조를 파악하고, 필요하면 10줄씩 더 보는 식으로 동작한다. 무엇보다 학습 가능한(RL learnable) 구조라는 점이 장점이다. (원문: “RL learnable”).\n\n무거운 모델 두 개를 엮는 구조보다 훨씬 단순하다. 또한 복잡한 고도형 구조를 이중으로 얽히게 두는 건 유지보수 측면에서도 거추장스럽다. (원문: “Camera vs Lidar” 비유는 두 기술 접근의 대비를 농담으로 강조한 것)\n\n작가가 농담처럼 언급했듯, LLM 시대의 `Camera vs Lidar` 구도가 떠오른다(원문: “Camera vs Lidar of the LLM era”). 즉 완전히 극단적 이분법은 아니고, 반은 농담, 반은 진심에 가깝다. (역자 주. Lidar는 거리측정 센서, Camera는 저비용·저정밀 방식의 은유로 이해하면 된다.)\n\n### 3.2 좋은 도구 설계: 저수준 vs 고수준\n\n‘에이전트에 어떤 도구를 줘야 하나’는 만드는 사람이라면 밤잠을 설칠 수 있는 고민이다. 높은 수준의 의미 기반 작업을 주는가, 아니면 키보드 타이핑·클릭처럼 저수준을 주는가.\n\n정답은 상황에 따라 다르고, 둘 다 써야 한다.\n\nCC는 저수준(Bash, Read, Write), 중간(Edit, Grep, Glob), 고수준(Task, WebFetch, exit_plan_mode) 도구를 모두 둔다.\n\nCC에 bash가 있으니 별도 Grep을 둘 필요가 없다는 의문이 들 수 있지만, 실제 사용 빈도를 보면 grep을 자주 쓰는 경향 때문에 따로 두는 편이 이득이다. 특수 상황에는 여전히 일반 bash 명령으로 처리한다.\n\nWebFetch, `mcp__ide__getDiagnostics`처럼 동작이 매우 결정적인 고수준 도구 역시 있다. 이는 모델이 저수준 입력/클릭 과정을 반복하는 비용을 줄여, 문제 해결 흐름을 덜 비틀리게 한다. 즉, 모델 부담을 줄여 주는 설계다.\n\n도구 설명은 구체적 예시를 많이 싣고, 같은 작업을 두 도구가 할 수 있을 때의 선택 기준까지 적어둔다.\n\nCC의 도구 목록:\n\n- Task\n- Bash\n- Glob\n- Grep\n- LS\n- ExitPlanMode\n- Read\n- Edit\n- MultiEdit\n- Write\n- NotebookEdit\n- WebFetch\n- TodoWrite\n- WebSearch\n- mcp__ide__getDiagnostics\n- mcp__ide__executeCode\n\n### 3.3 에이전트가 todo 목록 관리\n\n긴 실행 시간의 LLM 에이전트에서 맥락 붕괴(context rot)는 흔하다. 초반엔 어려운 문제를 잘 시작하다도, 시간이 지나면 정체가 무너져 쓰레기처럼 돌아가기도 한다.\n\n현재 에이전트들은 보통 명시적 todo를 실험한다: 한 모델이 todo를 만들고 다른 모델이 수행, 또는 PRD/PM → 구현 → QA의 다중 에이전트 승계 구조 같은 형태다.\n\n그러나 다중 에이전트 인계 자체가 좋은 선택은 거의 아니라고 저자는 본다. CC는 명시적인 todo 목록을 쓰되, 그 목록을 모델이 직접 유지한다. 모델은 todo를 자주 참조하라고 강하게 유도되고, 구현 중간에도 필요하면 새 항목을 추가하거나 기존 항목을 거절·수정하며 유연하게 경로를 바꾼다. 이는 `interleaved thinking`을 이용해 흐름을 즉시 조정하는 방식이다. (원문: \"interleaved thinking\")\n\n## 4. 조정 가능성(steerability)\n\n### 4.1 말투와 스타일\n\nCC는 에이전트의 ‘느낌 있는 동작’을 매우 의도적으로 통제한다. 시스템 프롬프트에는 말투, 스타일, 선제성 관련 섹션이 가득하며, 그것이 댓글 톤과 대응 태도까지 단정하게 만든다. 덕분에 코드 설명 없이도 정돈된 반응이 나온다.\n\n저자는 이 부분을 그대로 가져다 앱에 적용할 것을 권한다.\n\n예시:\n\n- IMPORTANT: 사용자 요청이 없으면 불필요한 머리말/꼬리말(예: 코드 설명 요약, 액션 요약)을 붙이지 말 것.\n- 요청하지 않은 기능 설명이나 정리도 기본적으로 생략.\n- 도와주지 못할 때는 이유를 늘어놓지 말 것(설교처럼 보이고 짜증 유발).\n- 이모지는 사용자가 분명히 요구하지 않으면 쓰지 말 것.\n\n### 4.2 “이건 중요합니다”류 표현이 아직은 최선의 조정 수단\n\n안타깝게도 모델이 “하지 말아야 할 일”을 따르게 만드는 건 여전히 어려운 편이다.\n\nIMPORTANT, VERY IMPORTANT, NEVER, ALWAYS 같은 키워드가 지금으로선 지뢰 구간을 피하게 만드는 데 가장 안정적이다. 미래엔 더 자연스럽게 조정 가능한 단계가 오겠지만, 지금은 이런 방식이 실용적이다.\n\n예시:\n\n- IMPORTANT: 사용자가 요청하지 않은 한 코멘트를 추가하지 말 것\n- VERY IMPORTANT: `find`, `grep`은 쓰지 말고 Grep, Glob, Task를 사용할 것\n- `cat`, `head`, `tail`, `ls`도 가능하면 배제하고 Read/LS를 사용할 것\n- 정말로 `grep`이 필요하면, `rg`부터 먼저 사용할 것\n- IMPORTANT: URL은 코딩 도움에 확신이 있을 때만 생성·추측\n\n### 4.3 알고리즘(휴리스틱+예시)로 작성\n\nLLM이 수행할 핵심 작업을 먼저 식별해, 그에 대한 알고리즘을 명시하는 게 핵심이다. 실제 모델처럼 역할 연기를 하며 예시를 여러 번 돌려 판단 지점을 모두 드러내면, 지시를 지키기 쉬워진다.\n\n큰 흐름도를 그리는 것도 유효한 방법이다. 이렇게 하면 의사결정이 구조화되고, 모델이 지시를 따라가기 쉬워진다.\n\n“수많은 해야 할 일 / 하면 안 되는 일” 목록을 한꺼번에 쓰면 유지보수가 어렵고 충돌이 생기기 쉽다. 프롬프트가 수천 토큰이면 충돌 규칙이 생겨 모델이 취약해진다.\n\nCC 시스템 프롬프트의 `Task Management`, `Doing Tasks`, `Tool Usage Policy` 항목은 이런 알고리즘을 구체적으로 제시하고, 수많은 상황별 휴리스틱·예시를 함께 제공한다.\n\n## Bonus: BigLab 프롬프트를 주의 깊게 보는 이유\n\nLLM 조정의 큰 비중은 사후 보정 데이터 분포(사실상 RLHF 경향)를 역추적하는 데 있다. JSON을 써야 하는지 XML을 써야 하는지, 도구 설명을 시스템 프롬프트에 넣을지 도구 정의로 둘지, 앱의 현재 상태는 어떻게 다룰지 같은 문제는 타사 구현을 보는 게 도움이 된다.\n\nCC의 설계는 매우 강한 운영 철학(`opinionated` 경향)을 갖고 있고, 이를 참고해 내 시스템을 고치는 게 효과적이다.\n\n## 결론\n\n핵심은 여전히 단순함이다. 과도한 프레임워크와 외부 확장은 오히려 역효과가 날 수 있다. CC를 통해 “에이전트는 단순해도 충분히 강력할 수 있다”는 믿음을 얻었고, MinusX에서도 그 교훈을 계속 반영하고 있다.\n\n자신만의 LLM 에이전트를 Claude식으로 정형화하고 싶다면, 저자는 대화나 공유를 환영한다고 밝혔다. 훈련 가능한 데이터 에이전트를 원한다면 MinusX를 참고하거나 데모를 신청하라.\n\nHappy (Claude) Coding!\n\n---\n\n## 부록\n\n- 메인 Claude Code 시스템 프롬프트 보기\n- 전체 Claude Code 도구 보기\n\n## 관련 글\n\n- [블로그 글 목록 보기](https://minusx.ai/blog/)\n- [Metabase AI](https://minusx.ai/metabase-ai/)\n- [요금제 보기](https://minusx.ai/pricing/)\n\n## 페이지 하단(번역)\n\n최신 업데이트 알림 구독을 위해 이메일 주소를 입력해 구독할 수 있다.\n이메일 주소\n구독\n\n연락: hi@minusx.ai\n\n© 2025 MinusX, Inc. 모든 권리 보유.\n\n### 제품\n\n- Chrome 확장 프로그램\n- Playground\n- GitHub\n- 문서\n\n### 기능\n\n- Metabase AI\n- MBQL AI Assistant\n- 대시보드 Q&A\n- 임베디드 AI\n\n### 회사\n\n- 요금제\n- 회사 소개\n- 블로그\n- 데모\n\n### 지원\n\n- 이용 약관\n- 개인정보 보호 정책\n- 신뢰 센터\n- 지원\n\n## 댓글 번역\n\n- 본문 소스에 공개 댓글 섹션이 없어 번역할 댓글 본문은 없습니다.",
      "filePath": "2026-02-23/minusx.ai-Claude_Code가_이렇게_뛰어난_이유__에이전트에서_그__마법_을_어떻게_재-1771855452152.md",
      "tags": [
        "ai",
        "클로드코드",
        "바이브코딩"
      ],
      "createdAt": "2026-02-23T14:04:12.152Z",
      "updatedAt": "2026-02-23T14:04:13.115Z"
    },
    {
      "id": "admin-1771855423450",
      "title": "Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까",
      "category": "ai",
      "type": "article",
      "source": "블로그",
      "sourceUrl": "https://minusx.ai/blog/decoding-claude-code/",
      "summary": "# reddit 유저의 클로드 코드 6개월 사용 후기\n\n- 원문 링크: https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/\n- 저자: JokeGold5455\n- 출처: www.reddit.com\n\n# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까\n\n원문 링크: https://minusx.ai/blog/decoding-claude-code/?utm_source=tldrnewsletter\n\n원문 서명/출처: vivek (@nuwandavek), MinusX\n\n## 이미지 설명\n- Claude Code 업데이트 차이를 선명하게 확인할 수 있음\n\n# Claude Code가 이렇게 뛰어난 이유: 에이전트에서 그 '마법'을 어떻게 재현할까\n\n/ [vivek](https://x.com/nuwandavek) / 2025-08-21\n\nClaude Code는 지금까지 내가 써 본 AI 에이전트/워크플로우 중 가장 쓰기 편한 도구다. 타깃 편집이나 즉흥적인 vibe 코딩에 쓰는 도구보다 단순히 덜짜증나는 수준을 넘어, 실제로 쓰는 사람이 만족감을 느끼게 만든다. 강력한 자율성으로 꽤 많은 일을 시킬 수 있으면서도, 다른 일부 도구들처럼 “제어권을 잃는 듯한” 이질감은 덜 준다. 물론 핵심적인 작업량은 최신 Claude 4 모델(특히 interleaved thinking, `문맥을 반씩 번갈아가며 판단하는 방식`(원문: \"interleaved thinking\")이) 덕분이다.\n\n동일 모델을 쓰는 Cursor나 GitHub Copilot 에이전트와 비교해도, Claude Code는 상대적으로 덜 번거롭게 느껴진다. 왜 이렇게까지 좋다고 느꼈을까? 이 글을 읽고 고개가 끄덕여진다면, 그 이유를 정리해보려 한다.\n\n참고: 이것은 Claude Code의 내부 구조를 공개하는 글이 아니다. 그 같은 글은 이미 충분히 존재한다. 이 글은 몇 달간의 직접 사용과 실측 로그 분석을 바탕으로, ‘쓸 만한 LLM 에이전트’를 만들기 위한 실무 가이드이다. 부록에서 프롬프트와 도구를 볼 수 있다. 약 2천 단어 분량이므로, 짧게 보려면 TL;DR부터 보는 게 좋다.\n\n이미지: prompts\n\nClaude Code의 업그레이드 흐름이 분명히 보임\n\nClaude Code(이하 CC)는 직관적으로 잘 동작한다. 이는 단순히 사용자 경험이 좋다는 뜻이 아니라, LLM이 잘하는 일과 못하는 일을 명확히 반영해 설계했기 때문이다. 프롬프트와 도구가 모델의 약점을 가리고 강점을 부각한다. 그래서 제어 루프가 매우 단순하고 디버깅하기 쉽다.\n\nMinusX에서는 공개 직후 바로 CC를 도입했다. 내부에서 덮어쓰기 없이 네트워크 요청을 가로채고 기록하는 로거를 만들어 분석 기반으로 사용했고, 아래 내용은 마지막 몇 개월간 집중 사용한 결과다. 이 글의 핵심 질문은 바로 이것이다. “Claude Code가 왜 그렇게 좋은가? 내 채팅형 LLM 에이전트에서도 같은 경험을 만들 수는 없을까?” 현재 대부분을 MinusX에 반영했고, 독자도 그대로 적용해보길 권한다.\n\n이미지: prompts\n\n가장 빈번하게 쓰이는 도구 순서는 Edit → Read → ToDoWrite였다.\n\n## Claude Code형 에이전트를 만드는 법: TL;DR\n\n한마디로 정리하면 이렇다. **복잡하게 가지 말고 핵심만 유지해야 한다**(원문: “Keep Things Simple, Dummy”). (역자 주. “dummy”는 비격식적 강조어라 직역보다 ‘핵심 단순화’로 의역했다.)\n\nLLM은 디버깅과 평가 자체가 어렵다. 여기에 멀티에이전트, 에이전트 인계 구조, 복잡한 RAG 검색 알고리즘 같은 추가 복잡성을 더하면 문제 해결이 10배 더 어려워진다. 겉보기엔 잘 돌아가는 취약한 시스템도, 한 번 돌아가기 시작하면 나중에 구조를 바꾸는 게 공포로 다가온다. 그래서 가능한 한 하나의 파일에 핵심을 두고, 과도한 보일러플레이트는 반복적으로 제거하는 게 낫다.\n\nClaude Code에서 가져갈 핵심 정리:\n\n### 1. 제어 루프\n- 1.1 한 개의 메인 루프(최대 한 갈래 분기)와 하나의 메시지 이력 유지\n- 1.2 거의 모든 단계에서 소형 모델 사용\n\n### 2. 프롬프트\n- 2.1 claude.md 패턴으로 사용자 선호를 공유·기억\n- 2.2 특수 XML 태그, Markdown, 그리고 풍부한 예시\n\n### 3. 도구\n- 3.1 LLM 기반 검색이 RAG 기반 검색보다 우선\n- 3.2 좋은 도구 설계(고수준 vs 저수준)\n- 3.3 에이전트가 자기 todo 목록을 직접 관리\n\n### 4. 조정 가능성(steerability)\n- 4.1 말투와 스타일\n- 4.2 “PLEASE THIS IS IMPORTANT”류의 강조 표현이 여전히 현실적인 조정 수단\n- 4.3 규칙을 나열하기보다 알고리즘·휴리스틱·예시로 설명\n\n> Claude Code는 아키텍처 수준에서 단순함을 택한다. 하나의 메인 루프, 간단한 검색, 단순한 todo 목록 등을 유지한다. 과도한 설계 대신 잘 제어된 실험 환경을 만들어 모델이 스스로 ‘요리’하게 두는 방식이다.\n> (원문: “Is this end-to-end self-driving all over again? Bitter lesson much?”)\n\n---\n\n## 1. 제어 루프 설계\n\n### 1.1 하나의 메인 루프만 유지\n\n디버깅 가능성은 다단계 다중 에이전트 구성을 넘는다.\n\n멀티 에이전트가 유행인 시대에도 CC는 실제로 하나의 메인 스레드만 유지한다. 필요한 경우에만, git 히스토리를 요약하거나 메시지 이력을 하나로 압축하거나 UX 장식을 구성하는 특수 프롬프트를 주기적으로 사용한다. 다만 전반적으로는 평평한(flat) 메시지 목록을 유지한다.\n\n계층형 작업 처리 또한 독특하게 접근한다. 추가 하위 에이전트를 생성하되, 새 하위 에이전트가 또다시 하위 에이전트를 만들 수는 없다.\n\n최대 한 갈래의 분기만 허용되고, 그 결과는 `tool response` 형태로 메인 메시지 이력에 반영된다.\n\n문제가 단순하면 메인 루프는 반복적인 도구 호출로 처리한다. 하지만 작업이 하나 이상의 복합 문제일 경우, 메인 에이전트가 자기 자신을 복제해 분기한다. 최대 한 갈래 제한과 todo 목록을 같이 쓰면, 문제를 하위 작업으로 나누되 최종 목표를 계속 바라볼 수 있다.\n\n내가 보기엔 다중 에이전트 구조가 꼭 필요할 가능성은 낮다. 추상화 계층이 늘어날수록 디버깅 난이도는 올라가고, 무엇보다 모델의 일반적 성능 개선 흐름에서 멀어질 수 있다.\n\n이미지: Control Loop\n\n### 1.2 모든 일에 작은 모델 사용\n\nCC의 주요 LLM 호출의 50% 이상이 claude-3-5-haiku로 처리되었다. 이 모델은 대용량 파일 읽기, 웹 페이지 파싱, git 히스토리 처리, 긴 대화 요약 같은 일에 쓰이며, 매 입력마다 1단어 처리 라벨을 생성하는 데까지 활용된다(`one-word processing label`, 원문: \"for every key stroke\").\n\n소형 모델은 Sonnet 4, GPT-4.1 같은 표준 모델 대비 70~80% 저렴하다. 과감히 써야 한다.\n\n## 2. 프롬프트\n\nClaude Code는 상당히 정교한 프롬프트를 사용한다. 휴리스틱, 예시, 그리고 IMPORTANT(원문: \"IMPORTANT\") 형태의 리마인더가 빈번하다. 시스템 프롬프트는 약 2800 토큰이며, 도구 설명은 약 9400 토큰 수준이다. 사용자 프롬프트에는 대개 claude.md가 들어가고, 보통 1000~2000 토큰이 추가된다.\n\n시스템 프롬프트에는 말투, 스타일, 선제성, 작업 관리, 도구 사용 정책, 작업 수행 방식이 모두 들어가고, 현재 날짜·작업 디렉터리·플랫폼·OS 정보·최근 커밋 내역 같은 실행 메타데이터도 반영된다.\n\n프롬프트 전부를 한 번 읽어보는 걸 권한다.\n\n### 2.1 claude.md로 사용자 맥락·선호도 협업\n\n많은 코딩 에이전트 제작자가 채택한 패턴은 컨텍스트 파일이다(CURSOR Rules / claude.md / agent.md 계열). CC는 claude.md 유무에 따라 성능 차이가 극단적으로 크다. 코드베이스에서 추론할 수 없는 팀/사용자 맥락을 전달하고, 강한 선호 조건을 고정하는 데 유용하다. 예를 들어 특정 폴더를 건너뛰거나 특정 라이브러리 사용을 강제할 수 있다. CC는 매 사용자 요청마다 claude.md 전체를 함께 전달한다.\n\nMinusX는 최근 `minusx.md`를 도입했다(원문: minusx.md). 내부적으로 팀·사용자 선호를 한 파일로 정리해 에이전트가 일관되게 따르도록 했다.\n\n### 2.2 특수 XML 태그, Markdown, 풍부한 예시\n\n프롬프트 구조화에 XML 태그와 Markdown이 널리 쓰인다는 점은 이미 알려져 있다. CC는 이 두 방식 모두를 크게 사용한다.\n\nCC에서 쓰는 주요 XML 예시:\n\n- `<system-reminder>`: 여러 섹션 끝에 배치해 모델이 자주 깜박이는 내용을 되새기게 함.\n\n  예시:\n\n  `<system-reminder>현재 todo 목록이 비어 있음을 상기합니다. 사용자에게는 이 사실을 굳이 알릴 필요 없습니다. todo 목록이 유리한 작업에서는 TodoWrite를 사용하세요. 필요 없다면 무시해도 됩니다. 이 메시지도 사용자에게 직접 노출하지 마세요.</system-reminder>`\n\n- `<good-example>`, `<bad-example>`: 휴리스틱을 고정하는 용도로 사용.\n\n  여러 합리적 경로가 동시에 열려 있을 때, 어떤 선택이 더 맞는지 대비가 필요할 때 유용하다.\n\n  예시:\n\n  `pytest /foo/bar/tests`가 좋은 예시이고\n\n  `cd /foo/bar && pytest tests`는 나쁜 예시인 것을 대비해 보여준다.\n\n또한 CC는 마크다운을 이용해 시스템 프롬프트를 명확한 절(section) 단위로 나눈다. 주요 섹션에는 말투·스타일, 선제성, 규약 준수, 코드 스타일, 작업 관리, 도구 사용 정책, 작업 실행, 도구 목록이 들어간다.\n\n## 3. 도구\n\n전체 도구 프롬프트 자체도 꼭 읽어볼 가치가 있다. (약 9400 토큰)\n\n### 3.1 LLM 검색이 RAG 검색보다 유리\n\nCC가 다른 인기 있는 코딩 에이전트와 구분되는 중요한 지점은 바로 RAG를 안 쓴다는 점이다. CC는 사용자가 직접 코드베이스를 다루는 것처럼 `ripgrep`, `jq`, `find` 같은 실제 검색 명령을 쓴다.\n\nLLM이 코드를 잘 이해하므로, 관련 코드 블록을 정규표현식으로 꽤 정교하게 찾아낼 수 있다. 때로는 더 작은 모델로 전체 파일을 읽기도 한다.\n\nRAG는 이론적으로 좋아 보이지만, 새로운 실패 모드가 생긴다. 유사도 함수가 무엇이어야 하는지, 리랭커는 무엇을 써야 하는지, 청크 단위는 어떻게 할지, 큰 JSON/로그를 어떻게 처리할지 등 판단 포인트가 많다.\n\nLLM 검색은 반면 간단히 JSON에서 10줄을 읽어 구조를 파악하고, 필요하면 10줄씩 더 보는 식으로 동작한다. 무엇보다 학습 가능한(RL learnable) 구조라는 점이 장점이다. (원문: “RL learnable”).\n\n무거운 모델 두 개를 엮는 구조보다 훨씬 단순하다. 또한 복잡한 고도형 구조를 이중으로 얽히게 두는 건 유지보수 측면에서도 거추장스럽다. (원문: “Camera vs Lidar” 비유는 두 기술 접근의 대비를 농담으로 강조한 것)\n\n작가가 농담처럼 언급했듯, LLM 시대의 `Camera vs Lidar` 구도가 떠오른다(원문: “Camera vs Lidar of the LLM era”). 즉 완전히 극단적 이분법은 아니고, 반은 농담, 반은 진심에 가깝다. (역자 주. Lidar는 거리측정 센서, Camera는 저비용·저정밀 방식의 은유로 이해하면 된다.)\n\n### 3.2 좋은 도구 설계: 저수준 vs 고수준\n\n‘에이전트에 어떤 도구를 줘야 하나’는 만드는 사람이라면 밤잠을 설칠 수 있는 고민이다. 높은 수준의 의미 기반 작업을 주는가, 아니면 키보드 타이핑·클릭처럼 저수준을 주는가.\n\n정답은 상황에 따라 다르고, 둘 다 써야 한다.\n\nCC는 저수준(Bash, Read, Write), 중간(Edit, Grep, Glob), 고수준(Task, WebFetch, exit_plan_mode) 도구를 모두 둔다.\n\nCC에 bash가 있으니 별도 Grep을 둘 필요가 없다는 의문이 들 수 있지만, 실제 사용 빈도를 보면 grep을 자주 쓰는 경향 때문에 따로 두는 편이 이득이다. 특수 상황에는 여전히 일반 bash 명령으로 처리한다.\n\nWebFetch, `mcp__ide__getDiagnostics`처럼 동작이 매우 결정적인 고수준 도구 역시 있다. 이는 모델이 저수준 입력/클릭 과정을 반복하는 비용을 줄여, 문제 해결 흐름을 덜 비틀리게 한다. 즉, 모델 부담을 줄여 주는 설계다.\n\n도구 설명은 구체적 예시를 많이 싣고, 같은 작업을 두 도구가 할 수 있을 때의 선택 기준까지 적어둔다.\n\nCC의 도구 목록:\n\n- Task\n- Bash\n- Glob\n- Grep\n- LS\n- ExitPlanMode\n- Read\n- Edit\n- MultiEdit\n- Write\n- NotebookEdit\n- WebFetch\n- TodoWrite\n- WebSearch\n- mcp__ide__getDiagnostics\n- mcp__ide__executeCode\n\n### 3.3 에이전트가 todo 목록 관리\n\n긴 실행 시간의 LLM 에이전트에서 맥락 붕괴(context rot)는 흔하다. 초반엔 어려운 문제를 잘 시작하다도, 시간이 지나면 정체가 무너져 쓰레기처럼 돌아가기도 한다.\n\n현재 에이전트들은 보통 명시적 todo를 실험한다: 한 모델이 todo를 만들고 다른 모델이 수행, 또는 PRD/PM → 구현 → QA의 다중 에이전트 승계 구조 같은 형태다.\n\n그러나 다중 에이전트 인계 자체가 좋은 선택은 거의 아니라고 저자는 본다. CC는 명시적인 todo 목록을 쓰되, 그 목록을 모델이 직접 유지한다. 모델은 todo를 자주 참조하라고 강하게 유도되고, 구현 중간에도 필요하면 새 항목을 추가하거나 기존 항목을 거절·수정하며 유연하게 경로를 바꾼다. 이는 `interleaved thinking`을 이용해 흐름을 즉시 조정하는 방식이다. (원문: \"interleaved thinking\")\n\n## 4. 조정 가능성(steerability)\n\n### 4.1 말투와 스타일\n\nCC는 에이전트의 ‘느낌 있는 동작’을 매우 의도적으로 통제한다. 시스템 프롬프트에는 말투, 스타일, 선제성 관련 섹션이 가득하며, 그것이 댓글 톤과 대응 태도까지 단정하게 만든다. 덕분에 코드 설명 없이도 정돈된 반응이 나온다.\n\n저자는 이 부분을 그대로 가져다 앱에 적용할 것을 권한다.\n\n예시:\n\n- IMPORTANT: 사용자 요청이 없으면 불필요한 머리말/꼬리말(예: 코드 설명 요약, 액션 요약)을 붙이지 말 것.\n- 요청하지 않은 기능 설명이나 정리도 기본적으로 생략.\n- 도와주지 못할 때는 이유를 늘어놓지 말 것(설교처럼 보이고 짜증 유발).\n- 이모지는 사용자가 분명히 요구하지 않으면 쓰지 말 것.\n\n### 4.2 “이건 중요합니다”류 표현이 아직은 최선의 조정 수단\n\n안타깝게도 모델이 “하지 말아야 할 일”을 따르게 만드는 건 여전히 어려운 편이다.\n\nIMPORTANT, VERY IMPORTANT, NEVER, ALWAYS 같은 키워드가 지금으로선 지뢰 구간을 피하게 만드는 데 가장 안정적이다. 미래엔 더 자연스럽게 조정 가능한 단계가 오겠지만, 지금은 이런 방식이 실용적이다.\n\n예시:\n\n- IMPORTANT: 사용자가 요청하지 않은 한 코멘트를 추가하지 말 것\n- VERY IMPORTANT: `find`, `grep`은 쓰지 말고 Grep, Glob, Task를 사용할 것\n- `cat`, `head`, `tail`, `ls`도 가능하면 배제하고 Read/LS를 사용할 것\n- 정말로 `grep`이 필요하면, `rg`부터 먼저 사용할 것\n- IMPORTANT: URL은 코딩 도움에 확신이 있을 때만 생성·추측\n\n### 4.3 알고리즘(휴리스틱+예시)로 작성\n\nLLM이 수행할 핵심 작업을 먼저 식별해, 그에 대한 알고리즘을 명시하는 게 핵심이다. 실제 모델처럼 역할 연기를 하며 예시를 여러 번 돌려 판단 지점을 모두 드러내면, 지시를 지키기 쉬워진다.\n\n큰 흐름도를 그리는 것도 유효한 방법이다. 이렇게 하면 의사결정이 구조화되고, 모델이 지시를 따라가기 쉬워진다.\n\n“수많은 해야 할 일 / 하면 안 되는 일” 목록을 한꺼번에 쓰면 유지보수가 어렵고 충돌이 생기기 쉽다. 프롬프트가 수천 토큰이면 충돌 규칙이 생겨 모델이 취약해진다.\n\nCC 시스템 프롬프트의 `Task Management`, `Doing Tasks`, `Tool Usage Policy` 항목은 이런 알고리즘을 구체적으로 제시하고, 수많은 상황별 휴리스틱·예시를 함께 제공한다.\n\n## Bonus: BigLab 프롬프트를 주의 깊게 보는 이유\n\nLLM 조정의 큰 비중은 사후 보정 데이터 분포(사실상 RLHF 경향)를 역추적하는 데 있다. JSON을 써야 하는지 XML을 써야 하는지, 도구 설명을 시스템 프롬프트에 넣을지 도구 정의로 둘지, 앱의 현재 상태는 어떻게 다룰지 같은 문제는 타사 구현을 보는 게 도움이 된다.\n\nCC의 설계는 매우 강한 운영 철학(`opinionated` 경향)을 갖고 있고, 이를 참고해 내 시스템을 고치는 게 효과적이다.\n\n## 결론\n\n핵심은 여전히 단순함이다. 과도한 프레임워크와 외부 확장은 오히려 역효과가 날 수 있다. CC를 통해 “에이전트는 단순해도 충분히 강력할 수 있다”는 믿음을 얻었고, MinusX에서도 그 교훈을 계속 반영하고 있다.\n\n자신만의 LLM 에이전트를 Claude식으로 정형화하고 싶다면, 저자는 대화나 공유를 환영한다고 밝혔다. 훈련 가능한 데이터 에이전트를 원한다면 MinusX를 참고하거나 데모를 신청하라.\n\nHappy (Claude) Coding!\n\n---\n\n## 부록\n\n- 메인 Claude Code 시스템 프롬프트 보기\n- 전체 Claude Code 도구 보기\n\n## 관련 글\n\n- [블로그 글 목록 보기](https://minusx.ai/blog/)\n- [Metabase AI](https://minusx.ai/metabase-ai/)\n- [요금제 보기](https://minusx.ai/pricing/)\n\n## 페이지 하단(번역)\n\n최신 업데이트 알림 구독을 위해 이메일 주소를 입력해 구독할 수 있다.\n이메일 주소\n구독\n\n연락: hi@minusx.ai\n\n© 2025 MinusX, Inc. 모든 권리 보유.\n\n### 제품\n\n- Chrome 확장 프로그램\n- Playground\n- GitHub\n- 문서\n\n### 기능\n\n- Metabase AI\n- MBQL AI Assistant\n- 대시보드 Q&A\n- 임베디드 AI\n\n### 회사\n\n- 요금제\n- 회사 소개\n- 블로그\n- 데모\n\n### 지원\n\n- 이용 약관\n- 개인정보 보호 정책\n- 신뢰 센터\n- 지원\n\n## 댓글 번역\n\n- 본문 소스에 공개 댓글 섹션이 없어 번역할 댓글 본문은 없습니다.",
      "filePath": "2026-02-23/minusx.ai-Claude_Code가_이렇게_뛰어난_이유__에이전트에서_그__마법_을_어떻게_재-1771855423450.md",
      "tags": [
        "ai",
        "클로드코드",
        "바이브코딩"
      ],
      "createdAt": "2026-02-23T14:03:43.450Z",
      "updatedAt": "2026-02-23T14:03:44.619Z"
    },
    {
      "id": "item-y9W79Tsnds_7W2C2qcNnVo",
      "title": "reddit 유저의 클로드 코드 6개월 사용 후기",
      "category": "ai",
      "type": "article",
      "source": "www.reddit.com",
      "sourceUrl": "https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/",
      "summary": "# reddit 유저의 클로드 코드 6개월 사용 후기\n\n- 원문 링크: https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/\n- 저자: JokeGold5455\n- 출처: www.reddit.com\n\n# Claude Code는 대단하다 — 6개월 하드코어 사용 후기: 실전 팁\n\n원문 링크: https://www.reddit.com/r/ClaudeAI/comments/1oivjvm/claude_code_is_a_beast_tips_from_6_months_of/\n\n원문 서명/출처: r/ClaudeAI (Reddit)\n\n많은 텍스트 음성 변환 AI(예: ElevenLabs Reader, Natural Reader)를 쓰면, 이 긴 글을 음성으로 들어가며 읽을 수 있습니다.\n\n수정 요청이 많아서 며칠 내로 저장소 링크를 올리겠다고 했고, 당시에는 사내 프로젝트 작업 연계라 바로 공개할 수 없어 익명 처리 시간이 필요했다고 설명했습니다.\n\n마지막 수정: 바로 정리해서 공개를 진행했고, 추가 내용은 포스트에 올리거나 아래 저장소에서 확인할 수 있다고 덧붙였습니다.\n\n**레포지토리:** https://github.com/diet103/claude-code-infrastructure-showcase\n\n# 면책조항\n\n저자는 1주일간의 강도 높은 사용기를 6개월 전 공개했지만, 최근에는 6개월 동안의 추가 실전 운영을 정리해 올렸고 내용이 길어질 수 있으니 마음의 준비를 하라고 말합니다.\n\n작성한 내용은 저자 본인 기준에서 잘 맞던 방식의 정리일 뿐 정답이 아니며, AI 에이전트 코딩 작업을 개선하기 위한 참고 자료로 봐 달라고 강조했습니다. 20x Max 플랜으로 진행했기 때문에 비용·사용량 체감은 다를 수 있고, vibe-coding만을 위한 팁이 아니라 협업·계획·리뷰·반복 개선 중심으로 써야 효과를 본다는 점도 명시했습니다.\n\n# 핵심 개요\n\n6개월 동안 Claude Code를 밀어붙여(단독으로 30만 LOC 정도를 재작성) 정리한 시스템은 다음 네 가지입니다.\n\n- 필요 시 실제로 자동 활성화되는 스킬\n- Claude가 맥락을 잃지 않도록 방지하는 개발 문서 워크플로우\n- PM2 + 훅으로 뒤처리되지 않는 오류 처리\n- 리뷰·테스트·기획을 담당하는 특화 에이전트군\n\n이제 본문으로 들어갑니다.\n\n# 배경\n\n저자는 7년가량 운영 환경 웹앱을 만드는 소프트웨어 엔지니어이며, AI를 위협이 아니라 생산성 레버리지로 사용합니다.\n\nAI 도입 이후 기존에는 시도하지 못했던 기능을 많이 만들고, Claude와 GPT-5 Thinking을 함께 써서 제안서/아이디어를 구성해 업무 프로세스를 확장했다고 설명했습니다.\n\n이 자신감으로 사내 내부 도구로 쓰던 하나의 큰 웹앱을 대규모로 리팩터링했습니다. 원래는 대학교 과제에 가깝던 노후한 프로젝트를 7년 전 시작해 4년 전 포크한 상태였고, 약 10만 LOC 프로젝트를 몇 달 안에 단독으로 개편하겠다는 무리한 일정까지 잡았습니다.\n\n현재는 약 6개월 뒤로, 당시 일정은 무리였을 가능성이 큽니다.\n\n이 과정에서 프런트엔드는 완전 교체했고, React, React Query, 라우팅, MUI 버전 등을 전부 최신 스택으로 바꿨습니다. 결과적으로 프로젝트는 30만~40만 LOC로 늘었고, 테스트 커버리지와 기술부채를 정비해 테스트 데이터 생성 CLI와 프런트 기능별 테스트용 Dev 모드도 만들었습니다.\n\n# 품질·일관성에 대한 코멘트\n\n포럼에서 반복적으로 보이는 “사용량 제한”과 “품질 저하” 불만을 무시하지 않되, 자기 방식이 정답은 아니라고 전제합니다.\n\n최근 들어 결과가 오히려 좋아졌다는 점을 본인이 겪었고, 자신의 워크플로를 꾸준히 다듬은 데 기인했다고 봅니다. 다만 Claude의 출력은 확률적 특성이 있어 같은 입력이어도 결과가 달라질 수 있고, 문구가 조금만 달라도 품질 편차가 크게 벌어집니다.\n\n# 직접 개입해야 하는 순간\n\nAI가 강력하더라도 만능은 아닙니다. 2분이면 끝낼 수 있는 문제를 Claude가 30분 동안 헤매면 그 즉시 사람이 직접 고치라고 조언합니다. 자전거 배우듯이 잠깐 손잡이를 잡아주는 개입이 필요할 때가 있다는 뜻입니다.\n\n실제 로직 퍼즐이나 상식 판단이 필요한 문제에서 인간 직관이 더 빨리 정답에 닿는 경우가 많고, “AI가 다 해줘야 한다”는 집착이 시간 낭비가 된다고 지적합니다.\n\n마지막 시간대에는 프롬프트 퀄리티가 떨어지기 쉬우니, 결과가 나쁘다면 프롬프트를 다시 점검해야 합니다.\n\n**프롬프트 재입력은 자주 하라**는 것이 핵심입니다. 더블 Escape로 이전 프롬프트를 꺼내고, 무엇을 원하지 않는지 기준으로 다시 요청하면 같은 질문도 훨씬 좋아진다는 점을 강조합니다.\n\n“Claude가 해줄 수 있는 것”보다 “무엇을 넘겨줄 수 있는 컨텍스트를 준비했는지”가 중요하다는 말로 마무리합니다.\n\n# 나의 시스템\n\n지난 6개월 동안 CC 관련 워크플로를 크게 바꿨고, 실제 체감은 꽤 좋았습니다.\n\n# 스킬 자동 활성화 시스템(게임 체인저)\n\n이 파트는 작업 방식 자체를 바꾼 핵심 요소입니다.\n\n## 문제\n\nAnthropic의 Skills 기능은 ‘휴대 가능한 재사용 가이드’를 제공해 대규모 코드베이스 일관성을 잡을 좋은 아이디어였지만, 실제로는 자동 사용되지 않았습니다. 키워드를 정확히 넣어도 기대만큼 호출되지 않았고, 파일이 트리거 대상이어도 적용되지 않는 일이 반복되어 답답했다고 합니다.\n\n## 전환점\n\n“그렇다면 Claude가 자동 사용 못 하면, 작업 전에 강제로 확인하게 하는 훅을 만들면?”이라는 발상으로 전환했습니다.\n\nTypeScript 훅을 활용해 다층의 자동 활성화 아키텍처를 만들었고, 실제 동작했다고 전합니다.\n\n## 동작 방식\n\n두 개의 주요 훅을 구성했습니다.\n\n### 1) UserPromptSubmit Hook (Claude가 사용자 메시지를 보기 전 실행)\n- 메시지에서 키워드와 의도 패턴 분석\n- 관련 스킬 후보 판단\n- Claude 맥락에 포맷된 리마인더 주입\n- 예: “레이아웃 시스템이 어떻게 동작하죠?”라고 물으면 질문 전에 “🎯 SKILL ACTIVATION CHECK - project-catalog-developer 사용” 같은 안내가 먼저 들어옴\n\n### 2) Stop Event Hook (Claude 응답 완료 후 실행)\n- 수정한 파일 분석\n- 위험 패턴 체크(try-catch, DB 작업, async)\n- 자기 점검 리마인더 표시\n- “에러 처리를 넣었나? Prisma 연산은 repository 패턴을 쓰나?” 같은 질문 포함\n- 차단형이 아니라 인지 리마인드\n\n# skill-rules.json 구성\n\n모든 스킬을 중앙 설정 파일에서 관리했습니다.\n\n- 키워드: `layout`, `workflow`, `database` 등\n- 의도 패턴: 정규표현식으로 행동 유형 분류\n- 파일 경로 트리거\n- 파일 내용 트리거(Prisma import, controller 패턴 등)\n\n예시 설정은 이전과 동일한 JSON 구조를 사용하며, 핵심은 필요한 스킬만 경량으로 유도하는 것입니다.\n\n# 결과\n\n이제 백엔드 코드를 다룰 때:\n\n1. 프롬프트 읽기 전에 스킬 제안 표시\n2. 관련 가이드 로드\n3. 패턴 일관성 유지\n4. 마지막에 셀프 리마인더 수행\n\n과거처럼 “또 예전 패턴을 썼다”는 일이 크게 줄고, 매번 수동으로 가이드를 요구할 필요가 사라집니다.\n\n# Anthropic 공식 권고를 따른 재설계\n\n공식 문서에서 메인 `SKILL.md`를 500줄 이하로 유지하고 리소스 파일로 분할하라고 권하다는 걸 알게 된 뒤, 기존 1500줄 이상 스킬이 비효율적임을 확인했습니다.\n\n그래서\no) `frontend-dev-guidelines`를 398줄 본문 + 리소스 10개 파일\n\nb) `backend-dev-guidelines`를 304줄 본문 + 리소스 11개로 쪼개고\n\n평소에 경량 본문만 먼저 읽히게 하고 필요할 때만 상세 리소스를 불러오도록 바꿨습니다. 토큰 효율이 상당히 개선됐습니다.\n\n# 현재 구성한 스킬 목록\n\n가이드/베스트 프랙티스:\n- `backend-dev-guidelines` — 라우트 → 컨트롤러 → 서비스 → 레포지토리\n- `frontend-dev-guidelines` — React 19, MUI v7, TanStack Query/Router 패턴\n- `skill-developer` — 스킬을 추가/관리하기 위한 메타 스킬\n\n도메인별:\n- `workflow-developer` — 복잡한 워크플로 엔진 패턴\n- `notification-developer` — 알림/메시지 시스템\n- `database-verification` — 컬럼명 오류 방지\n- `project-catalog-developer` — 대형 데이터그리드(프런트) 규칙\n\n# 왜 의미가 있었나\n\n스킬+훅 도입 전엔 기존 패턴이 자주 재사용되었고, 매번 BEST_PRACTICES.md를 떠올리며 확인해야 했습니다.\n\n도입 후에는:\n- 일관된 패턴 자동 적용\n- Claude가 코드 완성 전후로 자체적으로 점검\n- 가이드 준수 여부 신뢰성 상승\n- 리뷰/수정 소요 시간 감소\n\n큰 코드베이스에서 초기 세팅이 오래 걸리더라도 회수 기간이 짧다는 결론입니다.\n\n# CLAUDE.md와 문서 진화\n\n6개월 전 글에서 “규칙이 가장 중요한 친구”라고 했지만, 기존 CLAUDE.md가 비대해져 과도한 역할을 맡고 있었습니다. 또한 수천 줄 `BEST_PRACTICES.md`는 Claude가 가끔 읽고 가끔 무시했습니다.\n\n그래서 Claude와의 대화 시간을 써서 전체를 재정비했습니다.\n\n## CLAUDE.md에서 스킬로 옮긴 내용\n- TypeScript 표준\n- React 패턴\n- 백엔드 API/라우팅/서비스/레포지토리\n- 에러 처리·Sentry 연동\n- DB 사용 패턴(Prisma)\n- 테스트/성능 최적화\n\n이 모든 내용은 스킬로 옮겨 자동 활성화 훅을 통해 실제로 사용되게 했습니다.\n\n## CLAUDE.md에 남긴 내용\n- 프로젝트 고유 정보(약 200줄)\n- 빠른 실행 명령어\n- 서비스별 구성\n- 작업 관리 흐름(개발 문서 체계)\n- 인증 라우트 테스트 절차\n- dry-run/브라우저 도구 설정\n\n## 구조 변화\n\n```\n루트 CLAUDE.md(약 100줄)\n  ├── 공통 핵심 규칙\n  ├── repo별 CLAUDE.md 참조\n  └── 상세 가이드는 skills로 분리\n\n각 repo의 claude.md(50~100줄)\n  ├── PROJECT_KNOWLEDGE.md\n  ├── TROUBLESHOOTING.md\n  └── 자동 생성 API 문서\n```\n\n요약하면, 스킬은 “코드 작성 규칙”을 담당하고 CLAUDE.md는 “이 프로젝트의 동작 방식”만 담당하게 분리한 것입니다.\n\n# Dev Docs 시스템\n\n스킬만큼이나 CC 성능에 영향을 준 건 개발 문서 체계입니다. Claude는 맥락을 잃기 쉽기 때문에 작업을 시작할 때와 진행 중에도 문서가 필요합니다.\n\n## 대형 작업 시작 절차\n\n승인된 플랜으로 plan 모드 종료 후 다음을 만듭니다.\n\n1. `~/git/project/dev/active/[task-name]/` 폴더 생성\n2. 문서 3종 생성\n   - `[작업명]-plan.md` : 승인된 계획\n   - `[작업명]-context.md` : 핵심 파일/결정사항\n   - `[작업명]-tasks.md` : 체크리스트\n3. 진행 상황 즉시 갱신\n\n## 진행 중\n\n- `/dev/active/`에서 기존 태스크 확인\n- 다음 작업 전 3개 문서를 모두 읽기\n- 완료 시 `Last Updated` 갱신\n\n이 과정을 만들기 전에는 30분 전 계획을 다 깜빡 잊고 엇나가는 일이 자주 있었다고 합니다.\n\n# 계획 수립 방식\n\n계획은 필수입니다.\n\n- 구현 전에 최소한 planning mode로 접근해야 한다고 주장\n- 계획 전용 하위 에이전트 `strategic-plan-architect`를 운영해 컨텍스트 수집·구조 분석·단계 분해·리스크·성공 지표를 산출\n- 결과로 plan/context/tasks 문서를 출력\n\n에이전트 출력이 마음에 들지 않을 때 “안 됨” 처리하면 중단되는 특성에 불만이 있어, 같은 출력물을 메인 CC에서 실행 가능한 slash command(`/dev-docs`)로 미러링해 사용했습니다.\n\n계획 출력은 사람이 꼭 검토해야 하고, 승인 뒤 `/dev-docs` 명령으로 문서를 생성해 새 맥락에서 작업을 시작합니다. 컨텍스트가 부족하면 `/update-dev-docs`로 다음 단계와 완료 항목을 갱신해 이어 갑니다.\n\n구현 중에는 큰 작업이라도 한 번에 1~2개 섹션만 하게 분할해 리뷰와 점검 시간을 늘립니다.\n\n# PM2 기반 백엔드 디버깅\n\n프로젝트에 마이크로서비스가 많아 로그를 실시간으로 보기 어렵다는 문제가 있었습니다.\n\n## 문제\n\n서비스가 실행 중일 때 Claude가 로그를 직접 보지 못해 “무슨 일이 났는지”를 수동으로 복사/붙여넣기해야 했습니다.\n\n## 중간 대응\n\n`devLog`로 타임스탬프 로그를 남기는 방식은 동작했지만 실시간성·자동 재시작·운영 편의성이 부족했습니다.\n\n## PM2로 해결\n\n단일 명령으로 백엔드 서비스 전부를 PM2로 띄웠고,\n- 서비스별 독립 로그\n- 실시간 로그 조회\n- 크래시 자동 재시작\n- `pm2 logs`, `pm2 monit`\n- restart/stop 등의 단일 명령 관리\n\nbefore/after 차이가 큽니다. 프론트엔드는 hot reload가 안 되므로 `pnpm dev`로 별도 실행하지만, 백엔드에는 PM2가 유효했습니다.\n\n# 훅 시스템(잔해 없음)\n\n현재 리포지토리는 멀티레포 구조라 프런트+7개 백엔드 유틸이 동시에 얽혀 있었습니다. Claude가 빌드 명령을 안 돌리거나 일부러 누락해 두는 일이 문제였습니다.\n\n## 훅 #1 파일 수정 추적\n`Edit`/`Write`/`MultiEdit` 이후 수정 파일, repo, 시간 정보를 로그로 기록하는 훅을 둡니다.\n\n초기에는 즉시 빌드를 돌렸지만 비효율적이어서 후속 단계로 변경했습니다.\n\n## 훅 #2 빌드 검사\n`Stop hook`에서\n1) 수정된 repo 판별\n2) 빌드 실행\n3) TS 에러 확인\n4) 5개 미만은 Claude에 노출\n5) 5개 이상이면 자동 에러 수정 에이전트 권고\n6) 로그 보존\n\n이후 코드에 남아 있는 에러를 나중에 찾는 일이 사라졌습니다.\n\n## 훅 #3 Prettier\n응답 후 자동 포맷팅 훅을 두었지만, 시스템 리마인더 토큰이 커질 수 있다는 데이터가 공유되면서 제거했습니다.\n\n파일 크기가 크고 형식 변경이 많은 경우, 응답당 수십만 토큰이 소모될 수 있어 비용 효율이 나빠질 수 있습니다. 수동 편집 간격에서 포맷팅을 돌리는 쪽을 권장했습니다.\n\n## 훅 #4 에러 처리 리마인더\n수정 파일의 위험 패턴(try-catch, async, DB 호출, 컨트롤러) 등을 분석해\n- 에러 처리 필요 여부\n- Sentry/Prisma 처리\n같은 자기 점검 문구를 부드럽게 출력합니다.\n\n# 훅 파이프라인\n\nClaude 응답 → PostToolUse(필요 시 포맷) → build 체크 → 에러 리마인더 → 에러 발견 시 즉시 수정/권고 에이전트 호출로 이어지는 구조입니다.\n\n결국 “뒤처리되는 오류”를 줄여 “안심 작업” 상태를 만듭니다.\n\n# 스킬에 붙인 유틸 스크립트\n\nAnthropic 예제처럼 스킬 안에 실행형 유틸을 붙였습니다.\n\n예: 인증 라우트 테스트 스크립트\n\n```bash\nnode scripts/test-auth-route.js http://localhost:3002/api/endpoint\n```\n\n스크립트는 Keycloak 리프레시 토큰 획득, JWT 서명, 쿠키 생성, 인증 요청까지 처리하므로 Claude가 매번 새 스크립트를 짜지 않아도 됩니다.\n\n이 패턴을 더 확대해 스킬별로 더 많은 유틸을 붙일 예정이라고 했습니다.\n\n# 기타 도구\n\n## Mac용 SuperWhisper\n타이핑이 지쳐서 음성으로 명령할 때 유용했고, Claude가 긴 맥락 문장을 적절히 이해한다고 합니다.\n\n## Memory MCP\n패턴 기억을 거의 스킬이 해결하면서 덜 쓰게 되었지만, 프로젝트 고유 결정사항 기록엔 아직 유용합니다.\n\n## BetterTouchTool\n- 코드 파일 참조용 상대 경로 복사(‘@’ 자동 접두사)\n- 앱 전환 단축키\n- 반복 액션 제스처\n\n단순 앱 전환 최적화만으로도 비용이 아낄 만큼 이득이 있다고 언급합니다.\n\n## 범용 스크립트\n토막 토막되는 반복 작업을 자동화합니다.\n- 더미 테스트 데이터 생성\n- 인증 경로 테스트\n- DB 재설정/seed\n- 스키마 diff 검사\n- 백업/복구\n\n유용한 스크립트는 즉시 문서화하거나 관련 스킬에 붙여 맥락 관리 비용을 낮춥니다.\n\n# 문서의 중요성(방식은 진화)\n\n기획만큼이나 문서도 중요합니다. 작업 문서와 특성 문서는 함께 계속 작성합니다.\n\n차이점은 이제 문서가 스킬을 대체하지 않고 보완한다는 점입니다.\n\n- 스킬은 재사용 패턴/방법\n- 문서는 시스템 아키텍처, 데이터흐름, API, 통합 지점\n\n예:\n- 컨트롤러 생성 방법 → `backend-dev-guidelines`\n- 워크플로 엔진 동작 방식 → 아키텍처 문서\n- React 컴포넌트 작성법 → `frontend-dev-guidelines`\n- 알림 흐름 → 데이터흐름 다이어그램 + `notification` 스킬\n\n문서 수는 850개 이상이지만 이제는 범용 규칙이 아닌 프로젝트 특화로만 유지합니다.\n\n# 프롬프트 팁\n\n명령은 구체적으로 작성해야 합니다.\n\n“샤그 카펫은 욕실에 어울리나?” 같은 비유로 의도를 명확히 하듯, 원하는 결과를 분명히 해야 Claude도 정확히 맞습니다.\n\n구체성이 어려우면 조사 요청으로 시작해 여러 후보안을 받는 것도 방법입니다. 맥락을 직접 보기 위한 단계적 연구가 결국 비용을 줄여줍니다.\n\n리드(유도) 질문은 피하세요. 좋아 보이기 전용 질문은 편향을 유발합니다.\n\n# 에이전트·훅·슬래시 커맨드(트리오)\n\n## 에이전트\n\n- `code-architecture-reviewer`: 코드 베스트 프랙티스 점검\n- `build-error-resolver`: TS 에러 체계적 수정\n- `refactor-planner`: 리팩터링 계획 수립\n- `auth-route-tester`: 인증 라우트 테스트\n- `auth-route-debugger`: 401/403 원인 디버깅\n- `frontend-error-fixer`: 프런트 에러 진단/수정\n- `strategic-plan-architect`: 구현 계획 작성\n- `plan-reviewer`: 실행 전 계획 검토\n- `documentation-architect`: 문서 생성/갱신\n- `frontend-ux-designer`: 스타일/UX 보정\n- `web-research-specialist`: 웹 조사 지원\n- `reactour-walkthrough-designer`: UI 투어 생성\n\n역할은 모호하면 안 되고 반환물 포맷도 미리 규정해야 한다고 강조합니다.\n\n## 훅(재차 강조)\n\n훅 없이는:\n- 스킬이 사용되지 않음\n- 에러 누락\n- 일관성 저하\n- 자동 품질 검사 부재\n\n훅 덕분에:\n- 스킬 자동 활성화\n- 거의 잔여 에러 없는 상태\n- 자동 형식 정합성\n- 내장된 품질 인지\n\n## Slash 명령\n\n- `/dev-docs`: 전략적 상세 계획 생성\n- `/dev-docs-update`: 컨텍스트 압축 전 정리 갱신\n- `/create-dev-docs`: 승인 계획을 문서로 변환\n- `/code-review`: 아키텍처 리뷰\n- `/build-and-fix`: 빌드 실행 및 오류 수정\n- `/route-research-for-testing`: 라우트 탐색/테스트 실행\n- `/test-route`: 특정 인증 라우트 테스트\n\n짧은 명령 하나가 반복 지시를 재사용 가능한 템플릿으로 바꿔줍니다.\n\n# 결론\n\n저자의 6개월 정리:\n\n- 항상 먼저 계획한다.\n- 스킬 + 훅 조합이 자동 활용의 핵심이다.\n- Dev docs로 Claude의 맥락 이탈을 막는다.\n- 스스로 리뷰하도록 유도한다.\n- 백엔드에서는 PM2가 디버깅 난이도를 크게 낮춘다.\n- 팀 작업이면 훅/에이전트/문서를 조합하면 더 큰 효과.\n\n부가적으로:\n- 작업별 특화 에이전트\n- 반복 가능한 Slash 명령\n- 정교한 문서\n- 유틸리티 스크립트와 Memory MCP\n\n마지막까지 읽어준 독자에게 고마움을 표하며, 질문이 있으면 구체적으로 더 공개하겠다고 했습니다.\n\n요약:\nTypeScript 훅으로 Skills 자동 활성화를 만들고, Dev docs로 맥락 이탈을 방지하며, PM2 + 자동 에러 검사로 품질을 방어해 6개월간 30만 LOC 전후를 안정적으로 처리했다.\n\n## 댓글 번역\n\n- **tmoothy**: 아직도 Reddit인지, 아니면 위키피디아인지?\n  - **[삭제]**: 무한 출력이 좋지 않아요? 하나라도 빠지면 나중에 걸릴 수 있다는 얘기죠.\n  - **bbbggghhhjjjj**: 사람들은 너무 복잡하게 만들어서 스스로 똑똑해 보이려는 경우가 있어요. 본문 저자가 문서가 850개가 넘는다고 하니 실제 코드보다 문서가 더 많다는 뜻 아닌가요.\n    - **lucianw**: OP의 글 전체를 읽었고 품질이 높다고 봤습니다. 길다고 무시하지 말라고요. 저도 대기업에서 AI 에이전트를 실무에 적용하고 우리 시스템을 직접 설계하는 쪽이라, 본문 내용이 우리가 하는 것과 동일해 보입니다.\n      - **-Crash_Override-**: (비즈니스에서의 경험을 보고) 너무 창피하네요.\n  - **gefahr**: 저도 읽었습니다. 최소 두 명은 있는 것 같습니다.\n    - **NeedleworkerFew5205**: 저도 읽었지만 아직 완전히 소화하지는 못했습니다. 제 나이대라서 이해가 느린 편이고, 30년 전엔 임베디드와 저수준 최적화를 다뤘는데요. 최근 마이크로컨트롤러를 주로 하던 사람으로 Claude를 쓰기 시작해 8개 센서/칩용 드라이버를 3일 만에 만들었을 정도로 놀라웠습니다. 원래 Reddit은 기술 토론 용도로만 썼는데 Claude가 피드에 떠서 오늘 하루도 이 글을 여기서 봤고, 거의 새벽 SF 특집 다큐 같은 느낌이었어요.\n  - **Dex4Sure**: 30만 LOC가 넘는 코드라면 저도 소프트웨어 엔지니어로서 존중해야 할 작업입니다. 서두르지 말고 판단하려는 분들을 비난하지 말아야죠.\n  - **bman8810**: 코드는 문서의 컴파일 결과라는 관점이 좋습니다. 코드보다 문서를 먼저 잘 쓰자는 뜻이죠.\n    - **acrackingnut**: 코드는 결정적이지만 문서에서 코드로 바꾸는 AI 변환은 확률적입니다. 정밀한 결과가 필요한데 같은 입력이라도 결과가 크게 변할 수 있어요.\n    - **bman8810**: 다만 요구사항을 잘 정의한다면 원하는 결과를 일관되게 얻는 기준은 정해질 수 있습니다. 코드 자체가 계속 같아야 하는 게 아니라 결과가 일관되면 됩니다.\n      - **killersnail2417**: 그런 방식이 결국 코딩을 새로 발명하는 것 아닌가요?\n  - **JokeGold5455**: 전부가 아니에요. 이미 완성된 기능의 Dev 문서는 대부분 삭제 가능해도, 필요할 때 재활용할 수 있어 보존합니다. Claude 문맥에 붙이기만 하면 되니까요.\n- **Livid-Reward8282**: 언급한 훅들을 공유해줄 수 있나요? UserPromptSubmit 훅으로 어떤 스킬을 제안할지 궁금합니다.\n  - **JokeGold5455**: DM으로 요청한 분들처럼, 이번 주 안에 저장소 샘플을 준비해보려 합니다. 지금 글이 오래 된 초안처럼 남아 있어서 정리 중입니다. 당장 필요하면 글을 markdown으로 복사해 Claude 컨텍스트로 넣고 정리해도 됩니다.\n    - **theblackpen**: 꼭요, 좋은 글이네요.\n    - **maddada_**: GitHub 저장소도 같이 올려주면 좋겠어요.\n    - **spacenglish**: GitHub 공유 부탁드립니다. 저도 DM 보냈습니다.\n    - **meepz**: 법적 이름이 “enough people”인데 저는 그거로 쓰겠습니다.\n    - **No_Gas_3727**: GitHub로 실제 구현을 보고 싶네요. 정말 대단합니다.\n  - **zerdos**: 7일 뒤 알림\n  - **Mysterious-Union4241**: 7일 뒤 알림\n- **SamuelQuackenbush**: 이 커뮤니티에서 꽤 긴 시간 보냈고, 이 글은 지금까지 본 글 중 이해가 잘 되는 편입니다.\n  - **JokeGold5455**: 고맙다는 응원 덕분입니다.\n- **seatlessunicycle**: 훌륭한 글이네요. 훅은 모르지만 내 문제 해결에 맞는 답처럼 보여요.\n  - **_chromascope_**: 저도 마찬가지입니다. 훅이 가장 궁금해요. 개발자가 아니라서 전체는 어렵지만 생산성 팁만큼은 끝까지 읽었어요.\n- **Swashbuckler_75**: Claude Code 사용법을 이렇게 통찰력 있게 정리한 글은 상위 1% 안에 듭니다.\n- **lucianw**: 훅에 대한 설명이 핵심이라 전부 공감합니다. 그러나 Hook #3(Prettier Formatter)에서는 동의하지 않습니다. 대화 중 반복 포맷은 문맥 토큰 낭비를 키워 답변 품질을 떨어뜨릴 수 있습니다.\n  - **JokeGold5455**: Anthropic 문서에서도 PostToolUse 훅 예시로 Prettier를 쓰는 걸 확인해 정식 반영하려고 합니다. 다만 대용량 파일/맥락 제한이 심한 경우 Stop에서 돌리는 방식이 더 효율적일 수 있으니 주의사항을 추가하겠습니다.\n    - **lucianw**: 왜 Anthropic이 그렇게 권고하는지 정확한 의도는 모르겠지만, 실제 사용자 사례에서는 유저 입력-요청-툴 결과 사이의 반복이 많아 3회 내에 토큰이 급증한 적이 있습니다. 짧은 코드 diff라도 상단/하단 변경이 결합돼 리마인더가 전체 범위를 반영해 토큰이 늘어나는 문제가 있었습니다.\n      - **JokeGold5455**: 매우 유의미한 데이터 감사합니다. 곧 본문에 반영하겠습니다.\n        - **lucianw**: Anthropic 문서에도 “콘텍스트 창은 공공재”라는 문장이 있습니다. 각 토큰이 정당한지 스스로 묻는 사고가 중요하고, 파일 변경 알림으로 들어온 토큰도 같은 기준을 적용하면 좋겠습니다.\n- **macdigger**: 6개월 동안 AI 툴 비용이 대략 얼마였나요?\n  - **JokeGold5455**: 200 플랜 기준 총 약 1,200달러였습니다.\n    - **macdigger**: 그 정도면 나쁘지 않네요. 감사합니다.\n    - **PsychologicalWeird**: Pro 플랜으로는 가능했을까요? 개인 취미로 소규모 프로젝트만 한다면 20달러 선이 낫지 않나 싶습니다.\n      - **JokeGold5455**: Pro로는 어려웠겠지만, 100이라도 간격을 잘 나눠 쓰면 가능할 수 있다고 봅니다. 사람마다 맥락을 과도하게 붙이는 방식이 비용을 좌우하기 때문에, 관리가 중요합니다.\n- **Avidium18**: 와\n  - **ArcyRC**: 대단해요.\n  - **mrcaumartin**: 엄청 좋아요.\n    - **Important_Place2514**: 굉장히 놀랍습니다.\n- **[삭제됨]**: 삭제됨\n- **Zulfiqaar**: 좋은 글입니다. 훅 설정을 지금 해볼 생각입니다. CLAUDE.md의 핵심 규칙만 넣으면 실무에서 UI 프레임워크 오류가 많이 잡힐 것 같습니다.\n- **painvader**: 저장소를 따로 보고 싶습니다. 이론 글보다 실제 구성 샘플이 훨씬 도움이 될 듯해요.\n- **purposelycacophonic**: 맞아요.\n- **PettyHoe**: Spec-kit 비슷한 구조를 검토해보라는 제안이 있을 것 같습니다. 인간/LLM 공통으로 쓰기 좋다는 생각입니다.\n  - **BrilliantSquare4325**: Openspec가 더 낫다고 봅니다.\n- **clduab11**: AI 공포를 외치던 사람들이 이 글을 보고는 “보긴 했지만 안 읽었다”는 태도를 보이는 걸 보면, 결국 대비가 된 사람은 살아남는다는 증거죠.\n- **ToiletSenpai**: 정말 가치 있는 정보라 감사합니다.\n- **0sko59fds24**: 훅 좀 주세요.\n- **AlDente**: 훅과 스킬 사용법을 제대로 배워야겠네요. 유익한 글입니다.\n- **whats_a_monad**: 스킬 훅이 왜 이렇게 복잡한가요? 설명만 보면 CLAUDE.md를 파일 경로 기반으로 쓰면 되지 않나요?\n    - **lucianw**: 스킬/툴은 LLM이 스스로 사용할지 결정해야 하는데, 실제로는 그 판단이 약해요. Anthropic도 TodoWrite를 강제로 쓰게 하려 훅을 쓰는 점을 이미 쓰고 있고, 글쓴이 방식은 같은 원리입니다.\n    - **PaulRBerg**: 훗날 LLM이 이걸 자연스럽게 처리해주길 기대해요.\n- **kikkoman23**: 서브에이전트는 병렬 작업이고 스킬은 자연어로 트리거되는 것처럼 보입니다. slash 명령을 쓰는 대신 모델이 스스로 쓰게 하면 편해질 것 같습니다.\n- **dradik**: 코드 실행으로 표준문서를 동적으로 불러오는 스킬을 사용하고 있어요. 기준 인덱스를 먼저 읽고, 현재 문맥에 맞는 문서만 읽어 오도록 했습니다.\n- **WestminsterNinja**: 읽을만 합니다.\n- **johannthegoatman**: 놀라울 정도로 좋은 글입니다.\n- **odarkshineo**: 놀랍고, 많은 사람이 내용을 이해 못하는 게 더 놀랍네요.\n- **Ok_Paper1017**: 제 프로젝트에 맞춰 적용해보려 합니다. 단계적으로 구현했던 제 작업을 촉진시킬 좋은 자료예요.\n- **No_Explanation9824**: 매우 유용합니다. 이 많은 모듈(스킬, 훅, 에이전트)을 완성한 과정에서 어떻게 디버깅했는지 궁금합니다.\n- **Blackwater_7**: 한마디로 요약해 주세요.\n- **lasajo2771**: 코드 공유해 주세요.\n- **Veloder**: (요약) 스킬 자동주입 훅 + plan/context/tasks 문서의 결합으로 Claude가 집중을 잃지 않고 일관성을 높인다는 내용입니다.\n- **Ok_Lettuce_7939**: 배경이 어떻게 되시나요?\n- **dashingsauce**: 짜릿해요\n- **blakeyuk**: 오래 된 베테랑 개발자들도 결국엔 계획·문서·맞춤 프롬프트로 수렴한다는 게 와닿습니다.\n- **CuriousLif3**: 음성 입력은 저도 Speechify 쓰는데 더 좋은 옵션 탐색 중입니다.\n- **villagezero**: 개발자가 아니어도 초반 문맥 유지가 중요하다는 점이 공감됩니다. CC가 이전 프롬프트를 추적해준다면 토큰도 아끼고 안정성이 높아질 듯합니다.\n- **bernieth**: Cursor 워크플로에서도 비슷한 결론이 나옵니다. 규칙 파일을 파일 패턴(glob)으로 매핑하고, 문서 갱신과 소통을 짜임 있게 하면 좋습니다.\n- **musictechgeek**: Home Assistant 구현에도 이 방식으로 여러 도메인 스킬과 후처리를 적용했습니다.\n- **ragnhildensteiner**: 1000시간 공들인 뒤 10시간 실행이었는지, 실질적 절감이 있는지 궁금합니다.\n- **radshot84**: 디버깅 프론트는 DevTools MCP처럼 보완하면 좋겠네요.\n- **TFT_TheMeta**: 수고했습니다.\n- **WinterFox7**: 월 API 사용료가 얼마나 들죠?\n- **RepoBirdAI**: spec 기반 방식과 더 견고한 컨텍스트 관리가 같이 필요해 보입니다.\n- **Desperate-Ninja9194**: 커뮤니티가 지식을 함께 키우는 좋은 예입니다. 저장소 공유도 부탁드립니다.\n- **Ellipsoider**: 정보의 보고입니다.\n- **rieferX**: 공유 고맙습니다. 1개월 리마인드 설정.\n- **Dtaild**: 감사합니다.\n- **ResponsibilityDue530**: 이 많은 양을 읽을 시간이 있으신가요? (농담으로)\n- **ArielCoding**: 토큰이 부족하면 다중 데이터 소스를 한 곳으로 정리해 창고처럼 쓰고 Claude에 넘기는 게 좋겠네요.\n- **Current-Usual-24**: 정말 인상 깊습니다.\n- **bhupesh-g**: 여러 워크플로 중 가장 좋고 제 생각과도 정합적입니다.\n- **No_Swordfish1677**: 훌륭하고 실질적 도움입니다.\n- **Necessary-Cloud9881**: AI 사용자 초보입니다. 이 글 보며 많은 걸 배웁니다.\n- **fsharpman**: 제2의 BMAD식 과한 방법보단 실무적 팁이 좋습니다. 프롬프트를 바꾸는 것도 함께 연습해야겠죠.\n- **TinyDancer218**: 이 글을 Claude에 넣고 프로젝트 반영해봤습니다. 꽤 괜찮습니다.\n- **Kitae**: 방향은 맞는데 제가 갈 길이 더 남았다는 걸 깨달았습니다.\n- **_yemreak_**: 작업 결과가 궁금합니다. 지금 보며 감탄 중이며, PM2/CLI/타입기반 문서/훅을 적용해보려 합니다. 어떤 도움이 필요할지 피드백 주시면 도와드리겠습니다.\n- **bilboismyboi**: 핵심적인 정리였습니다. 스킬이 자동으로 안 걸리는 문제가 왜 있나요? 훅이 결국 수동 주입이 아닐까요?\n  - **JokeGold5455**: 원래는 자동이어야 하지만, 지금은 실제로 키워드를 정확히 넣어도 동작이 불안정했습니다. 그래서 훅을 임시 보완으로 쓰고 있습니다.\n- **mynameismati**: 매우 유익하고 고퀄입니다. 훅이 인상 깊네요. 저장소 확인하겠습니다.\n- **xzlhexi**: 저장\n- **Spatialsquirrel**: 이 체계가 내 작업 흐름을 많이 개선했고, dev/active 덕에 반복 설명이 줄었습니다.\n- **bobafan211**: 기능별 완료 정의를 두는 것도 좋은 방법입니다.\n- **Full_Sugar2203**: 정말 긴 작업이었는데도 잘 읽었고 휴식 필요합니다.\n- **Fabian-88**: 초보자 입장에선 하나하나 적용이 어려워요. 프로젝트마다 템플릿이 필요할까요?\n- **losko666**: 이런 워크플로를 구축하는 데 기간이 얼마나 걸리나요?\n  - **lucianw**: 훅을 익히고 동작하게 하려면 보통 2일 정도면 시작선입니다.\n- **Spartan859**: 감사합니다.\n- **kbkid**: 고맙습니다.\n- **Such-Elderberry-9035**: SKILL.md가 잘 안되는 문제를 자동 호출로 해결한 점이 흥미롭고, 왜 공장식 개선인지 궁금합니다.\n  - **JokeGold5455**: Anthropic 자체도 아직 완성되진 않은 부분이 있어요. 공식 답변도 “키워드 다 맞춰도 실패하는 경우는 기능 한계”라고 했습니다.\n    - **lucianw**: TodoWrite reminder 훅처럼, UserPromptSubmit에서 이미 이런 리마인더를 넣는 방식과 유사합니다.\n- **SBMagar**: 7일 알림\n- **hjrs**: 다른 워크플로와 비교해 큰 도움이 되었습니다.\n- **NotMyself**: 저장소가 없으면 적용이 어렵습니다.\n  - **JokeGold5455**: 요청이 많아서 곧 공개하려 합니다. 현재는 사내 프로젝트 내부 제약으로 일부를 분리 중입니다.\n    - **NotMyself**: Claude에게 이 글을 읽히고, 기술 스택과 목표를 주면 실행 계획 문서 형태로 요약 요청해도 되겠네요.\n- **txgsync**: 좋아요, 저장소는요?\n- **Willing_Reflection57**: 훅과 스킬은 핵심입니다.\n- **Veezq**: 7일 뒤 알림\n- **Veezq**: 7일 뒤 알림\n- **abhibansal53**: 커스텀 스킬·훅·에이전트·명령어 공유 부탁드립니다.\n- **Non-Issue-3967**: 처음 시작하는 입장에겐 정말 좋은 가이드네요.\n- **clockworkthrone**: 자세한 설명이 좋았습니다.\n- **AnonymousBoson**: 고생했다\n- **tuannvm**: 음성 링크 공유 감사합니다.\n- **Think_Wrangler_3172**: 매우 꼼꼼한 가이드고 커뮤니티 기여에 감사를 전합니다.\n- **DrDalenQuaice**: 앱 형태로 패키징하면 유료 구독도 기꺼이 할 것입니다.\n- **SnooHesitations9295**: 효과가 프로젝트별로 다르겠지만, DevExp가 나쁘면 사람에게나 Claude에게나 개선이 우선입니다.\n- **Muscle-Equal**: 좋습니다.\n- **pbosat**: 1주일 리마인드\n- **BunsenMcBurnington**: 훅 외엔 거의 대부분 동의. 제 프로젝트도 Node 12 기반 구형 스택에서 대규모 리팩터를 했고, 동일한 패턴으로 진행됐습니다.\n- **CossackNikolay**: 비개발자나 컨설턴트 업무에도 쓸 수 있나요?\n- **standard_deviant_Q**: Sonnet 4.5 평가: 실전 경험이 쌓인 귀한 지식.\n- **Tomr750**: 설정 공유해 주세요.\n- **EscapeCalm7171**: 훌륭한 글입니다.\n- **bingoheeler**: Skills가 1개월 전 출시인데 6개월 쓰셨다는 얘기는 어디서 나온 걸까요?\n- **rbur0425**: 스킬/서브에이전트/도구를 훅으로 강화한 점이 좋네요.\n- **Due-Ad5510**: 팀 단위로 확장하려면 어떻게 구조를 잡았는지 궁금합니다.\n- **wood_workin_dad**: 흥미롭고 저장소도 감사합니다.\n- **pragmasoft**: 주니어에게 예시를 먼저 보여준 뒤 재현하게 하는 방식이 효과적입니다. 예시를 훅으로 붙이는 방식으로 확장해보세요.\n  - **JokeGold5455**: 저쪽엔 이미 backend/frontend 스킬에 완성된 예시가 들어 있습니다.\n- **nicklazimbana**: 처음 리팩터링할 때 어디서 시작해야 하나요? 첫 사용자라 조언이 필요합니다.\n- **MannToots**: 저도 최근 여러 툴로 3개월 운영했고, 큰 리팩터링을 비슷한 방식으로 진행했습니다. 컨텍스트 분할이 핵심입니다.\n- **Just-Athlete-9229**: 너무 복잡하게 만들었네요.\n- **berenddeboer**: 훅 덕에 규정 준수율이 올라감에 동의합니다.\n- **iECOMMERCE**: 저도 시스템에 반영해보겠습니다.\n- **dopefish23**: AI 코딩이 2025년에도 제대로 정돈되지 않은 상태라는 역설을 보여준 글입니다.\n- **xtof**: `/create-dev-docs` 커맨드가 보이지 않는데 추가 계획이 있나요?\n- **clouddrafts**: 20년 운영 경험으로 비슷한 접근을 하고 있으며, 훅 기반 자동 활성화는 매우 괜찮습니다. Anthropic이 기능 정리를 더 다듬을 것으로 예상합니다.\n- **don-remote**: 좋아\n- **Narrow_Ground1495**: 제 제품에도 적용해본 결과입니다. 감사합니다.\n- **Full-Cell-7875**: 상세 가이드 많이 도움됐습니다.\n  - **JokeGold5455**: 길어서 공개에 망설였지만 결국 올려야겠다는 생각입니다.\n- **grelminar**: 세 번은 읽어야 이해되는 글입니다. 공유 감사합니다.\n- **Jamalm23**: Kiro에도 비슷한 기능이 있나요?\n- **Silent_Gap_7105**: 첫 글치고 매우 긴데 놀랍도록 좋습니다.\n- **muhieddine101**: 훌륭합니다. 전문가가 이런 가이드를 공개해줄수록 도움이 큽니다.\n- **Anthony12125**: 배달 업무자도 같은 방식으로 정확성 검증 프레임을 만들어 수익이 30% 오른 사례를 공유하며, Claude를 믿지 말고 검증 경로를 강제해야 한다고 말합니다.\n- **YuMystery**: 멋집니다. 공유 고마워요.\n- **Groveres**: 훌륭합니다.\n- **Life-Peak-2458**: 읽어주셔서 감사합니다.\n- **James_chuh**: Claude Code를 1개월 사용했는데 같은 문제를 겪었습니다. `/dev-docs` 후 종료 시점에서 작업이 유지되지 않습니다. CLAUDE.md에서 계속 프롬프트해야 하나요?\n- **lAmBenAffleck**: 40만 LOC에서도 훅+스킬 구조를 적용했는데, 테스트 관련 잘못된 스킬 선택 문제를 해결하려 Haiku 기반 프리프로세서를 넣고 핵심 스킬만 강제 주입한 사례를 공유했습니다.\n- **khanght**: 매우 좋습니다.\n- **Any-Locksmith649**: 확인\n- **Available_Tutor8594**: 놀라울 만큼 유익합니다. 시간 나면 디테일을 더 배우고 싶습니다.\n- **artvepa**: 대규모 멀티레포에서 신뢰성 계층을 얼마나 잘 설계할지에 대한 장문 칭찬. 기존 실패 모드 분석과 대응이 실제 운영형 품질 레이어와 일치합니다.\n- **ded_banzai**: 또 하나의 md 보고서를 쓰고 있어요.\n- **ageobot**: cursor 2에서도 유사한 레이아웃으로 대규모 리팩토링했으나 여기처럼 정교하지는 않았다는 반응.\n- **Striking_Outcome4894**: 실제 비용(Cost)도 더 알려주면 좋겠어요.\n- **Little-Flan-6492**: 비싸서 오래 못 쓰는 사람도 결국 직접 코딩으로 돌아옵니다.\n- **Fine-Sprinkles6668**: n8n 워크플로에 적용 가능한지 궁금합니다.\n- **sammcj**: Michael Caine 음성 스타일 TTS 변환 버전 링크 제공.\n- **monfera**: LOC가 3배가 되며 기대수명이 5년 줄었다는 배경은 어떻게 계산했는지 궁금합니다.\n- **Motor-Mushroom3399**: 자동화 가드레일(스킬/훅/리마인더) 덕분에 안정성을 얻는다는 실무적 통찰에 동의합니다.\n- **endre_szabo**: OP와 같은 궤도에 있는 건 큰 특권이라는 의견.\n- **gorimur**: 음성 입력이 진짜 게임 체인저라는 공감, superwhisper도 참고.\n- **CattleRepulsive95**: 확인\n- **NoNothing3862**: 많은 아이디어가 생겼습니다.\n- **Yeccu**: superpowers 플러그인과 겹치는 부분이 있어 비교가 궁금합니다.\n- **betnevs**: 좋아요\n- **omattman**: 매우 상세하고 유익합니다.\n- **thedavidmurray**: 깊이 있는 정보에 감사.\n- **SolarSalsa**: 6개월이었는데 동료들이 1년 뒤처리되는 건가요? ㅋ\n- **SolarSalsa**: 본문 문장을 시간비용 ROI로 계산해 보셨는지요?\n- **PickMajestic3038**: 정말 도움됩니다.",
      "filePath": "2026-02-23/www.reddit.com-reddit_유저의_클로드_코드_6개월_사용_후기-1771809663679.md",
      "tags": [
        "ai",
        "클로드코드",
        "바이브코딩"
      ],
      "createdAt": "2026-02-23T00:00:00.000Z",
      "updatedAt": "2026-02-23T14:00:03.979Z"
    },
    {
      "id": "item-qXS1WSjNNE-o7Rqb_KwjOP",
      "title": "하루만에 인생 고치는 법",
      "category": "ai",
      "type": "article",
      "source": "x.com",
      "sourceUrl": "https://x.com/thedankoe/status/2010751592346030461",
      "summary": "# 하루만에 인생 고치는 법\n\n- 원문 링크: https://x.com/thedankoe/status/2010751592346030461\n- 저자: Dan Koe\n- 출처: x.com\n\n# How to fix your entire life in 1 day\n\n## do this before 2026\n\n아마 당신은 새해 결심을 포기할 가능성이 큽니다.\n\n그리고 그게 괜찮습니다. 대부분 사람들도 그렇습니다. (연구에서 80~90%가 실패율이라고 보여줍니다) 왜냐하면 대부분의 사람들은 진심으로 내부적으로 변하고 싶어 하지 않기 때문입니다. 즉, 완전히 잘못된 방식으로 삶을 바꾸려 한다는 뜻입니다. 사람들은 남들이 다 하니까 새해 결심을 만듭니다. 인간은 자기 자신을 설득하기보다 타인에게 보이는 걸 더 중요하게 여기며, 지위 게임에서 피상적인 의미를 만들어내지만(원문: “status games”), 이 방식은 진짜 변화가 요구하는 바에는 미치지 못합니다. 진짜 변화는 “올해는 더 성실하고 생산적일 것이다”라고 스스로 다짐하는 수준보다 훨씬 더 깊습니다.\n\n당신을 깎아내리려는 글은 아닙니다. 내가 세운 목표보다 10배는 더 많이 포기해 왔고, 대부분의 사람들도 비슷할 거라 생각합니다. 다만 사람들이 삶을 바꾸려고 시도했지만 거의 항상 완전히 실패하는 사실은 여전히 참입니다. 그래서 1월에 헬스장에 사람이 몰리고, 2월에 다시 평범해지는 풍경이 밈이 된다는 건 이상한 일이 아닙니다.\n\n하지만 새해 결심 자체가 어리석다고 보더라도, 혐오스러운 현재의 삶을 돌아보는 건 언제나 유효합니다. 그 다음 더 나은 것으로 자신을 밀어붙이기 위해서죠. \n\n인간은 본성적으로 까다롭고(원문: b*tch), 최악은 자신에게 한 약속을 지키지 못해 무력해지는 순간입니다. 계속해서 바꾸고 싶다는 생각만 하고 실제로는 못 바꾸는 상태가 수년간 계속될 수 있습니다.\n\n사업을 시작하든, 몸을 바꾸든, 2주 안에 포기하지 않고 더 의미 있는 삶으로 리스크를 감수하든 간에, 나는 올해 2026에서 적용할 수 있게 행동 변화/심리학/생산성에 대한 7가지 아이디어를 소개하고자 합니다.\n\n이 글은 포괄적입니다.\n\n이건 읽고 지나가는 글이 아닙니다.\n\n책갈피해 두고, 노트를 만들어두고, 생각할 시간을 확보하고 다시 읽을 글입니다.\n\n끝까지 수행할 경우, 거의 하루 내내 깊이 파고드는 방식의 프로토콜이 나옵니다. 효과는 그 이상으로 오래 갑니다.\n\n제가 바라는 건, 끝까지 집중해서 읽고 따라오는 것만입니다. 지루하면 다음 섹션으로 건너뛴 뒤, 나중에 빈칸을 채워 다시 오셔도 됩니다.\n\n시작합니다.\n\n(이 글을 영상으로도 옮겼습니다.)\n\n[YouTube: K8K09g9XR4s](https://www.youtube.com/watch?v=K8K09g9XR4s)\n\n### I – You aren’t where you want to be because you aren’t the person who would be there\n\n새해 결심을 바라보면 사람들은 성공의 두 조건 중 하나만 봅니다.\n\n1. 목표를 향해 행동을 바꾸는 것 (덜 중요, 2차 과제)\n2. 자신을 바꿔서 행동이 자연스럽게 따라오게 하는 것 (가장 중요, 1차 과제)\n\n대부분의 사람들은 겉으로 보이는 목표를 세운 뒤, 몇 주간 결심으로 몰입하다가 다시 예전 습관으로 돌아옵니다. 무너짐이 어려워서가 아니라, 썩어 가는 토대 위에 위대한 삶을 짓고 있기 때문입니다.\n\n감이 안 잡힌다면 예를 들어보죠.\n\n성공한 사람을 하나 떠올려보세요. 완벽한 몸을 가진 보디빌더, 수억 달러의 회사를 운영하는 CEO, 아무 망설임 없이 사람들 앞에서 잘 이야기하는 사람.\n\n그 보디빌더가 건강하게 먹기 위해 “고생”해야 한다고 보이나요? CEO가 팀을 이끌기 위해 스스로를 단련해야 한다고 보이나요? 겉보기엔 그렇게 보여도, 진짜는 다릅니다.\n\n그들은 **다른 방식으로 살 수 있는 삶을 상상할 수가 없습니다**. 보디빌더는 비건이 아니라 **불건강하게** 먹는 쪽으로 자신을 몰아가고, CEO는 알람이 울린 뒤에도 침대에 더 오래 누워 있는 걸 억지로 견뎌야 합니다.\n\n누군가의 생활이 내게는 극단적·규율적일지 몰라도, 내게는 자연스럽습니다. 남과 비교하려는 의도보다 내가 즐기는 방식이기 때문입니다. 엄마가 “쉬어”라고 해도 나는 “지금도 즐거운데 왜 이러냐고?”를 입에 담지 않습니다.\n\n다음 문장은 가볍게 넘기지 마세요.\n\n원하는 결과가 있다면 그 결과를 만드는 **라이프스타일을 먼저 갖추어야 합니다**.\n\n누군가 30파운드를 감량하겠다고 말한다고 해서 쉽게 믿지 않습니다. 가끔 “빼고 나면 인생이 즐거워질 것”이라고 말하는 걸 자주 보이기 때문입니다. 체중을 빼는 방식은 평생 유지되는 습관이 돼야 하는데, 오랜 기간 더 높은 끌림(원문: *higher gravitational pull*)을 못 찾으면 결국 시작점으로 돌아갑니다.\n\n진짜로 자신을 바꾸면, 목표로 가는 데 기여하지 않는 습관은 점점 역겨운 수준으로 느껴집니다. 지금 수준이 괜찮은 건 그것이 어떤 결과로 이어지는지 아직 충분히 인식하지 못해서입니다. 이건 뒤에서 풀어봅니다.\n\n사람들은 “돈을 버는 삶”, “건강해지는 삶”을 원한다고 말하지만 행동은 다르게 보입니다. 생각보다 훨씬 더 깊은 층위가 여기서 시작됩니다.\n\n### II – You aren’t where you want to be because you don’t *want* to be there\n\n> Trust only movement. Life happens at the level of events, not of words. Trust movement.\n>\n> — 알프레드 아들러 (원문: *Trust only movement. Life happens at the level of events, not words*)\n\n자신을 바꾸려면 먼저 마음이 어떻게 작동하는지 이해해야 합니다.\n\n마음의 핵심을 이해하려면 행동이 목표 지향적이라는 점부터 봐야 합니다. 발을 옮기는 건 어떤 지점에 닿기 위해서고, 코를 긁는 건 간지러움을 없애기 위해서입니다.\n\n겉보기엔 간단해 보여도, 대부분의 목표는 무의식입니다. 점심 전에 쉬는 날처럼 보이는 행동에도 “다음 책임이 닥치기 전에 시간을 태우는” 목표가 숨어 있을 수 있습니다.\n\n더 심층적으로, 사람은 해롭기까지 한 목표를 사회적으로 그럴듯하게 정당화해 행동을 정당화합니다.\n\n예컨대 일을 미루는 걸 “의지력이 없다”로 설명하지만, 실제로는 **완성하고 공개되는 것에서 받는 판단을 피하고 싶은 욕구**가 더 깊은 목표일 수 있습니다.\n\n막연히 퇴사하겠다고 말해놓고 계속 제자리인 경우도 마찬가지입니다. 겉으로는 용기가 없다고 느끼거나 “모험가가 아니다”라고 생각할 수 있는데, 실제로는 안전·예측 가능·실패자로 보이는 걸 피하려는 목표를 좇는 것입니다.\n\n결론: 진짜 변화는 목표를 바꾸는 일입니다.\n\n제가 말하는 건 겉목표 설정이 아닙니다. 그렇게 설정하는 행위는 무의식적 손해 목표를 강화할 수도 있으니까요. 진짜는 관점(point of view)의 변화입니다. 목표란 미래를 향한 투사이고,\n지금 보이는 정보, 아이디어, 자원을 목표 달성 관점으로 필터링하게 만드는 렌즈입니다.\n\n이걸 이해하지 못하면 더 빠져나오기 어려워집니다.\n\n### III – You aren’t where you want to be because you’re afraid to be there\n\n> 핵심은, 아이디어가 어디서 왔는지와는 상관없다는 점입니다. 전문 최면사가 아니더라도, 어떤 신념을 받아들이고 그것이 진짜라고 굳게 믿으면, 그 신념은 최면사의 말처럼 똑같은 힘을 갖습니다.\n>\n> — 맥스웰 몰츠\n\n당신은 이렇게 현재의 자신이 되었고, 앞으로 되는 이유가 여기에 있습니다. 정체성의 구조는 이렇습니다.\n\n1. 목표를 갖는다.\n2. 그 목표로 현실을 본다.\n3. 목표 달성에 도움이 되는 “중요한” 정보만 눈에 들어온다.\n4. 그 목표로 향한 행동을 하고 피드백을 받는다.\n5. 반복해서 자동·무의식 행동이 된다.\n6. 그 행동이 **“나는 이런 사람이다”**라는 정체성 일부가 된다.\n7. 그 정체성을 지키려 한다.\n8. 정체성이 새로운 목표를 만들고 사이클이 재개된다.\n\n불행히도 6단계와 7단계 사이를 끊어야 하는데, 이 과정은 어린 시절부터 시작됩니다.\n\n당신은 생존을 목표로 삼습니다.\n\n생존을 가르치기 위해 부모에게 의존했고, 순응해야 했고, 보상·처벌을 통해 학습했습니다. 그 가치관을 채택하지 않으면 벌을 받는 구조였고, 그때까지는 스스로를 온전히 성찰할 수 없었습니다.\n\n부모 세대 역시 같은 과정을 거쳤고, 산업사회가 정해준 “성공” 모델을 대물림해 왔을 수 있습니다. 자녀에게서조차도 같은 패턴의 상속이 됩니다.\n\n신체 생존이 충족되면, 사람은 개념·이념 차원에서 살아남기를 시작합니다. 몸을 지키는 수준이 아니라 마음을 지키고 복제하는 수준이 됩니다.\n\n몸이 위협을 받으면 ‘투쟁 또는 도피’가 일어나듯, 정체성이 위협받을 때도 같은 반응이 일어납니다.\n\n정치적 이념에 강하게 동일시된 사람은 반대 의견에 직면하면 얼굴을 맞는 듯한 스트레스를 느낍니다. 감정의 진실을 분석하지 않으면, 주변 생각장벽에 갇혀 상대를 해치고 자신도 해치게 됩니다.\n\n종교적 환경에서 스스로 생각하지 못한 채 자란 사람도 자신과 다른 사람의 위협을 감당하지 못해 공격적으로 반응합니다.\n\n변호사, 게이머 등 특정 정체성으로 자동 태깅되어 “더 나은 행동”을 안 하게 되는 경우도 동일합니다.\n\n### IV – The life you want lies within a specific level of mind\n\n마음은 시간에 따라 예측 가능한 단계로 진화합니다.\n\n우리는 태어날 때 문화가 주입하는 생존형 스펀지처럼, 안전하고 보호받는 느낌을 위해 어떤 믿음이든 흡수합니다. 조심하지 않으면 마음이 굳어져 의미 있는 삶을 살기 어려워집니다.\n\n마슬로우, 그루터 단계 모델, 스파이럴 다이내믹스 같은 구조 안에서도 이 틀을 볼 수 있습니다.\n\n이건 제가 여러 번 설명해온 **Human 3.0 모델**에서도 반복되는데, 여기서는 9단계를 80/20으로 요약합니다.\n\n- **충동기반 단계(Impulsive)** — 충동과 행동이 분리되지 않는다. 흑백식 사고.\n- **자기보호 단계(Self-Protective)** — 세상은 위험하다. 자신을 숨기고 맞추는 게 생존.\n- **순응단계(Conformist)** — 집단이 곧 현실처럼 느껴진다.\n- **자기인식 단계(Self-Aware)** — 내면의 진심이 겉모습과 다름을 처음 본다.\n- **성실단계(Conscientious)** — 스스로의 원칙 체계를 만들고 자기 기준을 지킨다.\n- **개인주의 단계(Individualist)** — 형성된 원칙이 맥락의 산물임을 알아차린다.\n- **전략가 단계(Strategist)** — 체계 안에서 일하며, 자기가 개입하는 바를 자각한다.\n- **구성물 인식 단계(Construct-Aware)** — 정체성 포함한 모든 틀을 유용한 은유로 본다.\n- **일체성 단계(Unitive)** — ‘나’와 ‘삶’의 분리가 약해지고 일상이 하나로 감각된다.\n\n대부분은 4~8단계 사이에 있을 거라고 가정해도 무방합니다. 4에 가까운 사람은 현실적 통합이 어렵고, 8에 가까운 사람은 변화보다 이해를 위한 독서에 가깝습니다. 단계 간 차이는 큽니다.\n\n좋은 소식은 지금 어느 단계에 있든 상관없이, 이동은 패턴을 따라 일어난다는 점입니다.\n\n### V – Intelligence is the ability to get what you want out of life\n\n> 진짜 지능의 시험은 인생에서 원하는 것을 얻을 수 있느냐입니다.\n>\n> — 나발 라빅 (원문)\n\n성공의 공식은 세 가지 재료로 본 적이 있습니다.\n\n첫째 **주도성(Agency)**, 둘째 **기회(Opportunity)**, 셋째 **지능(Intelligence)**입니다.\n\n주도성은 크지만 기회가 없다면 목표 자체가 열매 맺기 어렵습니다. 기회와 주도성이 있어도 지능이 낮으면 기회를 제대로 활용하지 못합니다.\n\n기회는 대부분 이미 눈앞에 있습니다. 특히 디지털에서 풍부한 기회는 물리적 이동만으로는 해결되지 않습니다. 이번엔 ‘지능’이 어떤 건지 보겠습니다.\n\n> 사이버네틱스는 그리스어 *kybernetikos*에서 왔고, “조종하다” 혹은 “잘 조종하다”를 뜻합니다.\n> 즉 ‘원하는 것을 얻는 기술’과도 통합니다.\n\n따라서 나발의 정의를 따른다면, 지능은 인생에서 원하는 것을 얻는 능력이고 사이버네틱스는 그 속도를 높입니다.\n\n사이버네틱스가 보여주는 건 **지능적 시스템**의 속성입니다.\n\n- 목표를 갖는다.\n- 목표로 행동한다.\n- 현재 위치를 감지한다.\n- 목표와 비교한다.\n- 다시 그 피드백에 따라 행동을 수정한다.\n\n\"시스템의 반복(iteration)과 시행착오 지속성을 보고 지능을 판단할 수 있다\"고 말한 한 줄이 있습니다.\n\n삶에서 목표에 도달하려는 행위, 감지, 비교, 메타적으로 맥락 파악이 곧 고지능의 핵심입니다.\n\n지능 낮음의 표지: 실수에서 배우지 못함.\n\n문제를 만나면 고착되고 도망치거나 포기합니다. 글쓰기를 예로 들면, 독자를 못 모으면 시도를 바꾸고 실험하지 못해 포기합니다. 실제로는 효과적인 과정은 만들 수 있는데(그건 신념과 상관없이), 제한된 지능의 태도로 못 본 척합니다.\n\n충분히 긴 시간축을 두면 어떤 문제도 해결 가능한 것이고, 원하는 목표는 결국 달성 가능합니다. 다만 지금은 자원이 없을 수 있고, 그 자원은 미래에 만들어질 수도 있습니다.\n\n‘목표’는 인생을 바라보는 방식입니다.\n\n목표는 이 세상에서 “성공”과 “실패”의 정의를 바꾸고, 즐거움을 구성합니다. 목표가 잘못되면 여정의 즐거움도 깨집니다.\n\n내 마음의 운영 체제는 현실입니다.\n\n그리고 그 운영 체제는 목표로 구성됩니다.\n\n많은 사람에게 목표는 부모나 사회가 정해준 라인입니다.\n\n- 학교를 가라.\n- 일자리를 얻어라.\n- 분노를 느껴라.\n- 피해자 역할을 해라.\n- 65살엔 은퇴해라.\n\n이건 알려진 길이며, 잘 안 씁니다.\n\n지능을 높이려면:\n\n- 알려진 길을 버리고,\n- 미지의 영역에 들어가고,\n- 더 높은 목표를 세워 마음을 확장하고,\n- 혼돈을 받아들이고,\n- 자연의 일반 원리를 공부하며,\n- 깊은 일반론자가 되어야 합니다.\n\n### VI – How to launch into a completely new life (in 1 day)\n\n> 내 삶의 가장 좋은 시기는, 진행이 전혀 없는 상태에 참을 수 없어 지쳐버린 뒤 찾아왔습니다.\n\n질문입니다.\n\n- 어떻게 마음을 파고들 것인가?\n- 어떻게 조건화된 반응을 인식할 것인가?\n- 어떻게 삶의 궤적을 바꾸는 통찰로 들어갈 것인가?\n\n정답은 결국 **질문**입니다. 생각이 희박해도 질문은 사고를 시작하게 합니다. 그래서 질문을 잘하는 사람이 적다는 사실이 문제입니다.\n\n매년 당신의 삶을 리셋하고 급격한 성장기로 진입하게 도와줄 종합 프로토콜을 드릴게요. 거시에서 미시까지 묻습니다: 어디가 되고 싶은지, 그것에 필요한 것이 무엇인지, 바로 다음 행동은 무엇인지.\n\n이건 하루 종일 필요합니다. 펜, 종이, 열린 마음으로 진행하세요.\n\n정체성이 바뀌는 패턴은 보통 긴장 축적 후 급히 나타나며, 3단계를 거칩니다.\n\n1. **부조화(Dissonance)** — 현재 삶에 맞지 않음을 강하게 느낌.\n2. **불확실성(Uncertainty)** — 다음이 뭔지 몰라 흔들리거나 길을 잃음.\n3. **발견(Discovery)** — 원하는 방향을 발견하고, 빠르게 진전을 만드는 단계.\n\n이 프로토콜의 목표는 이 과정을 유도해, 분산되지 않는 명확성으로 오게 하는 것입니다.\n\n하루 구성은 이렇습니다.\n\n- 아침: 심리 발굴(자기동기/숨은 원인 탐색)\n- 낮: 중단 알림을 통한 자동행동 방해\n- 저녁: 통찰 정리로 실행 방향 설정\n\n모두에게 다 맞는 건 아니므로, “클라이맥스를 책 초반에” 기대하면 안 됩니다.\n\n#### Part 1) Morning – Psychological Excavation – Vision & Anti-Vision\n\n먼저 당신의 마음이 작동하는 새로운 렌즈를 만드십시오.\n\n새 갑옷을 입고 천천히 익숙해지는 과정이라고 보면 됩니다.\n\n15~30분(짧은 유튜브 영상 하나 정도) 정도를 둬서 아래 질문에 답하세요. 이 성찰은 AI에 넘기지 마십시오. 머리의 제한장치를 깰 목적입니다.\n\n1) 지금의 삶에서 이미 익숙해져버린, 고통스럽지만 견디고 있는 점은? (심한 고통이 아니라, “참을 만큼 익숙해진 불편”)\n2) 반복적으로 불평하지만 실제로 바꾸지 않는 것은? 지난 1년간 반복한 불평 3가지를 적으세요.\n3) 말이 아니라 행동을 본 누군가는 당신이 실제로 원하는 게 무엇인지 어떻게 읽을까요?\n4) 현재 삶에서 깊이 감추고 싶지만 참기 힘든 진실은?\n\n5) 앞으로 5년간 아무 것도 바뀌지 않는다면 평범한 화요일을 묘사해 보세요. 몇 시에 일어나고, 몸은 어떤 느낌인지, 가장 먼저 드는 생각은 무엇인지, 오전 9시~오후 6시는 어떻게 보내는지, 밤 10시는 어떤 느낌인지.\n6) 10년으로 늘려보면? 무엇을 놓쳤는지, 어떤 기회가 사라졌는지, 누가 등을 돌렸는지, 당신이 없을 때 사람들이 뭐라고 말하는지.\n7) 인생의 마지막이라고 가정하면, 안전한 버전만 살아왔습니다. 비용은 얼마였는지? 느끼지 못한 감정과 시도는?\n8) 당신의 미래를 이미 살고 있는 사람은? 5·10·20년 뒤를 봤을 때 함께 할 것 같은 사람은 어떤 사람인지. 감정은?\n9) 진짜 변화를 위해 포기해야 할 정체성은? (원문: “I am the type of person who...”) 사회적으로 어떤 대가가 있나?\n10) 바꾸지 못한 가장 창피한 이유는? 합리적으로 들리기보다 약하고 게으르고 두려운 사람처럼 보이게 만드는 이유는?\n11) 지금의 행동이 자기보호라면, 무엇을 지키려는 건가? 그 보호가 무엇을 가져왔는가?\n\n답이 정직했다면, 현재 삶의 불편함이 크게 살아오며 혐오감까지 느낄 수 있습니다.\n\n다음엔 반대 개념인 **희망의 최소 단위**를 만듭니다. 비전은 처음엔 흐릿하지만, 시간이 지날수록 정교해집니다.\n\n12) 현실적인 계획을 3년 뒤 상상하지 말고, **있는 그대로 원하는 삶**을 상상하세요. 3년 뒤 실제로 살고 있는 장면을 자세히 써보세요. (질문 5와 같은 수준의 구체성)\n13) 그 삶이 억지처럼 느껴지지 않으려면 자기 자신에 대해 무엇을 믿어야 하나요? 정체성 문장: “나는 ~한 사람이다.”\n14) 이미 그 사람이 된 상태라면 이번 주에 무엇을 하나라도 즉시 하나씩 실행할 수 있나요?\n\n이 질문들은 다음날 아침 첫 일과로 답하세요.\n\n#### Part 2) Throughout The Day – Interrupting Autopilot – Breaking Unconscious Patterns\n\n저널링은 시작일 뿐입니다. 진짜는 패턴 분해입니다.\n\n하루 종일 part 1의 기록을 계속 들여다봅니다. 반복이 되지 않게 무시하지 마십시오.\n\n지금 휴대폰에 리마인더/일정으로 질문을 넣고, 그 순간 바로 생각을 시작하세요.\n\n시간표가 겹치지 않게 랜덤하게 배치할수록 좋습니다.\n\n- **11:00am:** 지금 내가 하고 있는 일로 무엇을 피하고 있는가?\n- **1:30pm:** 지난 2시간을 누가 촬영했다면, 그 영상에서 내 인생의 바람은 무엇이라 읽을까?\n- **3:15pm:** 내가 가고 있는 길은 싫은 삶인지 바라는 삶인지?\n- **5:00pm:** 정말 중요하지만, 중요한 척 안 하고 있는 건 무엇인가?\n- **7:30pm:** 오늘 정체성 보호 때문에 한 행동은 무엇인가? (힌트: 대개 대부분의 행동)\n- **9:00pm:** 오늘 가장 살았던 순간은 언제였고, 가장 죽은 듯했을 때는 언제였나?\n\n이외에 출퇴근, 걷는 길, 누워있을 때도 추가 질문을 넣으세요.\n\n- 질문 10에서 쓴 정체성으로 보이려는 욕구가 사라진다면 내가 어떻게 달라질까?\n- 내 삶에서 생동감을 안전감과 교환하고 있는 곳은 어디인가?\n- 내일이면 될 수 있는 ‘미래의 나’ 버전 중 가장 작은 단위는 무엇인가?\n\n#### Part 3) Evening – Synthesizing Insight – Entering A Season Of Progress\n\n진정으로 과정을 거치면 적어도 하나의 깊은 통찰이 나옵니다. 이를 알리고, 통합하고, 행동으로 바꿔야 합니다.\n\n15) 오늘을 돌아봤을 때, 내가 멈춘 원인은 가장 타당하게 무엇인가?\n16) 실제 적은 적(적대자)는 누구인가? 상황? 사람? 아니면 오래 굴러온 내면의 패턴인가?\n17) 내 삶에서 절대로 되돌리고 싶지 않은 걸 한 문장으로 써보세요. 이것이 당신의 anti-vision 압축문입니다.\n18) 당신이 점차 만들어갈 방향을 한 문장으로 써보세요. 이것이 vision MVP입니다.\n\n이제 목표를 다시 정의합니다.\n\n다시 강조하지만, 목표는 성취물 자체가 목적이 아닙니다. 목표는 시야이며, 상태를 바꾸기 위한 렌즈입니다. 목표 자체는 고정되지 않고 바뀝니다. 마침표 같은 완주점은 없습니다. 성장은 진행 그 자체에서 기쁨을 얻습니다.\n\n19) **1-year lens:** 1년 뒤, 기존 패턴이 깨졌다는 걸 알 수 있는 구체적 1가지 신호는?\n20) **1-month lens:** 1개월 뒤, 1년 렌즈가 유지될 조건은 무엇인가?\n21) **Daily lens:** 내일 할 수 있는 2~3가지 시간차단행동은 무엇인가?\n\n양이 많았습니다.\n\n도움이 되길 바랍니다.\n\n마지막으로 이를 고정할 한 단계가 남았습니다.\n\n계속 읽어주세요.\n\n### VII – Turn Your Life Into A Video Game\n\n> 최적의 내적 상태는 의식 안에 질서가 생기는 상태입니다. 정신적 에너지(혹은 주의력)가 현실적인 목표에 투자되고, 행동 기회와 기술이 맞아떨어질 때 발생합니다.\n> 목표 추구는 주의를 한 과제에 집중시켜 그 순간 다른 모든 것을 잠시 잊게 만듭니다.\n>\n> — 미할리 치크센트미하이\n\n이제 좋은 삶을 만드는 구성 요소가 모두 모였습니다.\n\n한 장에 정리해 보세요.\n\n- **Anti-vision**: 더 이상 원치 않는 내 삶의 지옥이 무엇인지\n- **Vision**: 하고 싶은 이상적 삶은 무엇이며, 점진적으로 개선되는 것인지\n- **1 year goal**: 1년 뒤 내 삶이 어떤지, 원하는 삶에 가까워졌는지\n- **1 month project**: 무엇을 배워야 하고, 어떤 역량이 필요하며, 무엇을 만들어내면 1년 목표가 가까워지는지\n- **Daily levers**: 우선순위가 높은, 핵심 진행도를 밀어올리는 일들\n- **Constraints**: 이상을 세울 때 어떤 선을 양보하지 않을지\n\n왜 이게 강력한가?\n\n이 구성요소가 자기만의 작은 세계를 만듭니다.\n당신이 이 목표 계층을 이 시점에서 따라가야 한다면, 더 이상 흩어질 수 없게 됩니다. 더 큰 끌림이 생기고, 다른 선택지 자체가 사라집니다.\n\n당신은 인생을 게임으로 만듭니다.\n\n게임은 몰입, 즐거움, 플로우의 좋은 예시입니다. 집중과 선명도를 만드는 요소가 모두 들어 있습니다.\n거꾸로 생각해보면, 그 요소를 우리 삶에 역설계해 적용하면 산만함이 줄고 성공률은 올라갑니다.\n\n당신의 **Vision**은 게임의 **승리 조건**(win)입니다. (게임이 진화하기 전까지는)\n\n당신의 **Anti-vision**은 **걸림돌의 대가**(stake)입니다. 진다거나 포기했을 때 생기는 손실입니다.\n\n**1 year goal**은 **미션**입니다. 이것이 인생의 최우선순위입니다.\n\n**1 month project**는 **보스전**입니다. XP를 얻고 보상을 쌓는 단계입니다.\n\n**Daily levers**는 **퀘스트**입니다. 기회를 여는 일상적 과정입니다.\n\n**Constraints**는 **규칙**입니다. 창의성을 키우는 제약입니다.\n\n이 모두가 동심원처럼 중첩되어 잡념과 번쩍이는 유혹으로부터 마음을 지켜줍니다.\n\n게임을 더 오래 플레이할수록 이 힘은 강해지고, 곧 그것이 곧 당신의 본성처럼 됩니다.\n\n(원문: “you wouldn’t have it any other way”) \n\n— Dan",
      "filePath": "2026-02-23/x.com-하루만에_인생을_고치는_법-1771809812485.md",
      "tags": [],
      "createdAt": "2026-02-23T00:00:00.000Z",
      "updatedAt": "2026-02-23T13:59:23.686Z"
    }
  ]
}